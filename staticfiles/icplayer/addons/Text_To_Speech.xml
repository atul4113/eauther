<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Text_To_Speech" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Configuration" isDefault="true" name="configuration" nameLabel="Text_To_Speech_configuration" type="list">
            <property name="ID" nameLabel="Text_To_Speech_property_id" type="string"/>
            <property displayName="Area" name="Area" nameLabel="Text_To_Speech_area" type="{Main, Header, Footer}"/>
            <property isLocalized="true" name="Title" nameLabel="Text_To_Speech_property_title" type="string"/>
        </property>

        <property isLocalized="true" name="EnterText" nameLabel="Text_To_Speech_property_enter_text" type="string"/>
        <property isLocalized="true" name="ExitText" nameLabel="Text_To_Speech_property_exit_text" type="string"/>
        <property isLocalized="true" name="NewPage" nameLabel="Text_To_Speech_property_new_page" type="string"/>
        <property isLocalized="true" name="PageLangTag" nameLabel="Text_To_Speech_property_page_lang_tag" type="string"/>
    </model>
<css>.addon_Text_To_Speech {&#13;
    position: relative;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
</css><view/><preview/><presenter>function AddonText_To_Speech_create() {&#13;
&#13;
    function getErrorObject (ec) { return {isValid: false, errorCode: ec}; }&#13;
&#13;
    function getCorrectObject (v) { return {isValid: true, value: v}; }&#13;
&#13;
    function getTextVoiceObject (text, lang) { return {text: text, lang: lang}; }&#13;
&#13;
    function getConfObject (id, area, title, description) {&#13;
        return {&#13;
            id: id,&#13;
            area: area,&#13;
            title: title,&#13;
            description: description&#13;
        };&#13;
    }&#13;
&#13;
    var presenter = function () {};&#13;
&#13;
    presenter.messagesQueue = [];&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        C01: 'Configuration cannot be empty',&#13;
&#13;
        S01: 'Sorry, your browser does not support speech synthesis.'&#13;
    };&#13;
&#13;
    presenter.LANGUAGES_CODES = {&#13;
        English: 'en-US',&#13;
        Polski: 'pl-PL',&#13;
        Deutsch: 'de-DE',&#13;
        DEFAULT: 'English'&#13;
    };&#13;
&#13;
    presenter.AREAS = {&#13;
        Main: 'main',&#13;
        Header: 'header',&#13;
        Footer: 'footer',&#13;
        DEFAULT: 'Main'&#13;
    };&#13;
&#13;
    function parseConfiguration(configuration) {&#13;
        if (!configuration) {&#13;
            return getErrorObject('C01');&#13;
        }&#13;
&#13;
        var addOnsTextToSpeechData = [];&#13;
        for (var i = 0; i &lt; configuration.length; i++) {&#13;
            var conf = configuration[i];&#13;
            addOnsTextToSpeechData.push(getConfObject(&#13;
                conf.ID,&#13;
                ModelValidationUtils.validateOption(presenter.AREAS, conf.Area),&#13;
                conf.Title&#13;
            ));&#13;
        }&#13;
&#13;
        return getCorrectObject(addOnsTextToSpeechData);&#13;
    }&#13;
&#13;
    function parseLanguage(language) {&#13;
        return getCorrectObject(presenter.LANGUAGES_CODES[language || 'English']);&#13;
    }&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var validatedConfiguration = parseConfiguration(model['configuration']);&#13;
        if (!validatedConfiguration.isValid) {&#13;
            return getErrorObject(validatedConfiguration.errorCode);&#13;
        }&#13;
&#13;
        return {&#13;
            ID: model.ID,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isValid: true,&#13;
&#13;
            addOnsConfiguration: validatedConfiguration.value,&#13;
            enterText: model['EnterText'],&#13;
            exitText: model['ExitText'],&#13;
            newPage: model['NewPage'] ? model['NewPage'] : "New page",&#13;
            pageLangTag: model['PageLangTag']&#13;
        }&#13;
    };&#13;
&#13;
    function loadVoices () {&#13;
        presenter.configuration.voices = window.speechSynthesis.getVoices();&#13;
    }&#13;
&#13;
    presenter.presenterLogic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        view.addEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        loadVoices();&#13;
        window.speechSynthesis.onvoiceschanged = function (e) {&#13;
            loadVoices();&#13;
        };&#13;
&#13;
        if ('speechSynthesis' in window) {&#13;
&#13;
        } else {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'S01');&#13;
            return false;&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    function getAddOnConfiguration (area, id) {&#13;
        id = Array.isArray(id) ? id[0] : id;&#13;
        area = Array.isArray(area) ? area[0] : area;&#13;
&#13;
        for (var i = 0; i &lt; presenter.configuration.addOnsConfiguration.length; i++) {&#13;
            var conf = presenter.configuration.addOnsConfiguration[i];&#13;
&#13;
            if (conf.id === id &amp;&amp; conf.area.toLowerCase() === area.toLowerCase()) {&#13;
                return conf;&#13;
            }&#13;
        }&#13;
&#13;
        return {title: '', description: ''};&#13;
    }&#13;
&#13;
    function getResponsiveVoiceLanguage (langTag) {&#13;
        if (!langTag) {&#13;
            // get lang from document &lt;html lang=""&gt;&#13;
            langTag = document.documentElement.lang;&#13;
        }&#13;
&#13;
        // Tags for Identifying Languages: https://www.ietf.org/rfc/bcp/bcp47.txt&#13;
        var languages = {&#13;
            'en': 'UK English Male',&#13;
            'pl': 'Polish Female',&#13;
            'de': 'Deutsch Female'&#13;
        };&#13;
&#13;
        return languages[langTag] || 'UK English Male';&#13;
    }&#13;
&#13;
    function getSpeechSynthesisLanguage (langTag) {&#13;
        if (!langTag) {&#13;
            // get lang from document &lt;html lang=""&gt;&#13;
            langTag = document.documentElement.lang;&#13;
        }&#13;
&#13;
        loadVoices();&#13;
&#13;
        var languages = {&#13;
            'en': "en-US",&#13;
            'pl': 'pl-PL',&#13;
            'de': 'de-DE'&#13;
        };&#13;
        langTag = languages[langTag] || langTag;&#13;
&#13;
        for (var i=0; i&lt;presenter.configuration.voices.length; i++) {&#13;
            if (presenter.configuration.voices[i].lang === langTag) {&#13;
                return presenter.configuration.voices[i];&#13;
            }&#13;
        }&#13;
&#13;
        return presenter.configuration.voices[0];&#13;
    }&#13;
&#13;
    function filterTexts (texts, languageGetter) {&#13;
        return texts.map(function (t) {&#13;
            return {&#13;
                lang: languageGetter(t.lang),&#13;
                text: t.text ? t.text : ''&#13;
            };&#13;
        }).filter(function (t) { return t.text !== '' });&#13;
    }&#13;
&#13;
    // https://responsivevoice.org/&#13;
    function responsiveVoiceSpeak (texts, finalCallback) {&#13;
        var textsObjects = filterTexts(texts, getResponsiveVoiceLanguage);&#13;
        if (finalCallback === undefined) finalCallback = null;&#13;
&#13;
        var onEndStack = { onend: finalCallback };&#13;
        for (var i=textsObjects.length-1; i&gt;=0; i--) {&#13;
            var textObject = textsObjects[i];&#13;
&#13;
            if (i === 0) {&#13;
                window.responsiveVoice.speak(textObject.text, textObject.lang, onEndStack);&#13;
            } else {&#13;
                onEndStack.onend = (function (textObject, onEndStack) {&#13;
                    return function () {&#13;
                        window.responsiveVoice.speak(textObject.text, textObject.lang, onEndStack);&#13;
                    }&#13;
                })($.extend({}, textObject), $.extend({}, onEndStack));&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.intervalId = null;&#13;
&#13;
    // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis&#13;
    function speechSynthesisSpeak (texts, finalCallback) {&#13;
        window.speechSynthesis.cancel();&#13;
&#13;
        if (presenter.intervalId != null) {&#13;
            clearInterval(presenter.intervalId);&#13;
            presenter.intervalId = undefined;&#13;
        }&#13;
        // Fix for running speak method after cancelling SpeechSynthesis queue&#13;
        presenter.intervalId = setInterval(function() {&#13;
&#13;
            if (window.speechSynthesis.speaking) {&#13;
                window.speechSynthesis.cancel();&#13;
                return;&#13;
            }&#13;
            var textsObjects = filterTexts(texts, getSpeechSynthesisLanguage);&#13;
            if (textsObjects.length === 0) {&#13;
                clearInterval(presenter.intervalId);&#13;
                presenter.intervalId = undefined;&#13;
                return;&#13;
            }&#13;
            if (presenter.intervalId == null) return;&#13;
            presenter.utterances = [];&#13;
            for (var i=0; i&lt;textsObjects.length; i++) {&#13;
                var textObject = textsObjects[i];&#13;
                var msg = new SpeechSynthesisUtterance(textObject.text);&#13;
                msg.volume = parseFloat(1); // 0 - 1&#13;
                msg.rate = parseFloat(1); // 0 - 10&#13;
                msg.pitch = parseFloat(1); // 0 - 2&#13;
                msg.voice = textObject.lang;&#13;
                var currentIntervalId = presenter.intervalId;&#13;
                if (i === 0) {&#13;
                    msg.onstart = function (event) {&#13;
                        clearInterval(currentIntervalId);&#13;
                        if (currentIntervalId !== presenter.intervalId) {&#13;
                            window.speechSynthesis.cancel();&#13;
                        }&#13;
                    };&#13;
                }&#13;
                if (i === textsObjects.length - 1) {&#13;
                    msg.onend = function (event) {&#13;
                        if(currentIntervalId === presenter.intervalId){&#13;
                            window.speechSynthesis.cancel();&#13;
                        }&#13;
                        if (finalCallback){&#13;
                            finalCallback();&#13;
                            presenter.utterances = [];&#13;
                        };&#13;
                    };&#13;
                }&#13;
&#13;
                //this list and "push" is solving the problem on&#13;
                //'end' event of SpeechSynthesisUtterance object is not dispatched sometimes&#13;
                //https://www.e-learn.cn/content/wangluowenzhang/603510&#13;
                presenter.utterances.push(msg);&#13;
                window.speechSynthesis.speak(msg);&#13;
            }&#13;
        }, 250);&#13;
    }&#13;
&#13;
    function getAltTextOptions(expression) {&#13;
        var options = {};&#13;
        expression = expression.replace(/.*}\[/g, '');&#13;
        expression = expression.replace('\]\[', '|');&#13;
        expression = expression.replace('\]', '');&#13;
        var optionExp = expression.split('\|');&#13;
        for(var i=0;i&lt;optionExp.length;i++) {&#13;
            var optionValues = optionExp[i].split(' ');&#13;
            if(optionValues.length===2){&#13;
                options[optionValues[0]]=optionValues[1];&#13;
            }&#13;
        }&#13;
        return options;&#13;
    }&#13;
&#13;
     presenter.parseAltTexts = function(texts){&#13;
        for (var i=0; i &lt; texts.length; i++) {&#13;
            if (texts[i].text !== null &amp;&amp; texts[i].text !== undefined &amp;&amp; texts[i].text.trim().length &gt; 0)&#13;
            {&#13;
                // altText elements with a langTag need to be isolated into seperate items&#13;
                // in the texts array, so that they can use a different language tag.&#13;
                var match = texts[i].text.match(/\\alt{([^{}|]*?)\|([^{}|]*?)}(\[([a-zA-Z0-9_\- ]*?)\])+/g);&#13;
                if (match &amp;&amp; match.length&gt;0) {&#13;
                    // get the first altText element with a lang tag.&#13;
                    // if there are more, they will not be parsed in this iteration&#13;
                    // instead, they will become a part of the tail and will be parsed in future iterations&#13;
                    var matchText = match[0].trim();&#13;
                    var originalMatchText = matchText;&#13;
                    var splitTexts = texts[i].text.split(matchText);&#13;
                    var startIndex = texts[i].text.indexOf(matchText);&#13;
                    var readableText = matchText.replace(/.*\\alt{[^{}|]*?\|([^{}|]*?)}.*/g,"$1");&#13;
                    var options = getAltTextOptions(originalMatchText);&#13;
                    var langTag = "";&#13;
                    if(options.hasOwnProperty('lang')){&#13;
                        langTag = options.lang;&#13;
                    }&#13;
&#13;
                    if (langTag.length!==0) {&#13;
                        var altTextVoice = getTextVoiceObject(readableText, langTag);&#13;
&#13;
                        if (splitTexts) {&#13;
                            if (splitTexts.length &gt; 2) {&#13;
                                // It is possible that there will be multiple identical altText elements&#13;
                                // if that is the case, all elements of the splitTexts array should be merged&#13;
                                // with the exception of the head&#13;
                                var newSplitTexts = splitTexts.splice(0, 1);&#13;
                                newSplitTexts.push(splitTexts.join(originalMatchText));&#13;
                                splitTexts = newSplitTexts;&#13;
                            }&#13;
                            if (splitTexts.length === 2) {&#13;
                                texts[i].text = splitTexts[0];&#13;
                                texts.splice(i + 1, 0, getTextVoiceObject(splitTexts[1], texts[i].lang));&#13;
                                texts.splice(i + 1, 0, altTextVoice);&#13;
                            } else if (splitTexts.length === 1) {&#13;
                                texts[i].text = splitTexts[0];&#13;
                                if (startIndex === 0) {&#13;
                                    texts.splice(i, 0, altTextVoice);&#13;
                                } else {&#13;
                                    texts.splice(i + 1, 0, altTextVoice);&#13;
                                }&#13;
                            } else if(splitTexts.length === 0) {&#13;
                                texts[i] = altTextVoice;&#13;
                            }&#13;
                        }&#13;
                    } else {&#13;
                        //if there is no lang option, there is not reason to create a new element in texts array&#13;
                        texts[i].text = texts[i].text.replace(originalMatchText, readableText);&#13;
                    }&#13;
                }&#13;
&#13;
                // handle altText elements without a langTag&#13;
                texts[i].text = texts[i].text.replace(/\\alt{.*?\|(.*?)}/g, '$1');&#13;
            }&#13;
        }&#13;
&#13;
        // splitting matched texts might create elements with an empty text field. This removes them&#13;
        texts = texts.filter(function(element){return element &amp;&amp; element.text &amp;&amp; element.text.trim().length&gt;0});&#13;
        return texts;&#13;
    };&#13;
&#13;
    // The speak method is overloaded:&#13;
    // texts argument can be either an array of TextVoiceObjects, or a String&#13;
    // langTag argument is optional and only used when texts is a String&#13;
    presenter.speak = function (texts, langTag) {&#13;
        var class_ = Object.prototype.toString.call(texts);&#13;
        if (class_.indexOf('String') !== -1) {&#13;
            texts = [getTextVoiceObject(texts, langTag)];&#13;
        }&#13;
&#13;
        presenter.speakWithCallback(texts, null);&#13;
    };&#13;
&#13;
    presenter.speakWithCallback = function (texts, callback) {&#13;
&#13;
        texts = presenter.parseAltTexts(texts);&#13;
        if (window.responsiveVoice) {&#13;
            responsiveVoiceSpeak(texts, callback);&#13;
            return;&#13;
        }&#13;
&#13;
        if ('speechSynthesis' in window) {&#13;
            speechSynthesisSpeak(texts, callback);&#13;
            return;&#13;
        }&#13;
&#13;
        console.log(texts);&#13;
        if (callback) {&#13;
            callback();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.playTitle = function (area, id, langTag) {&#13;
        if (area &amp;&amp; id) {&#13;
            var textVoices = [getTextVoiceObject(getAddOnConfiguration(area, id).title, langTag)];&#13;
            var module = null;&#13;
            if(0 === area.toLowerCase().localeCompare("main")){&#13;
                module = presenter.playerController.getModule(id);&#13;
            } else if (0 === area.toLowerCase().localeCompare("footer")) {&#13;
                module = presenter.playerController.getFooterModule(id);&#13;
            } else if (0 === area.toLowerCase().localeCompare("header")) {&#13;
                module = presenter.playerController.getHeaderModule(id);&#13;
            }&#13;
            if (module !== undefined &amp;&amp; module !== null &amp;&amp; module.hasOwnProperty('getTitlePostfix')) {&#13;
                textVoices.push(getTextVoiceObject(module.getTitlePostfix(), langTag));&#13;
            }&#13;
            presenter.speak(textVoices);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.playPageTitle = function () {&#13;
        var textVoices = [];&#13;
        textVoices.push(getTextVoiceObject(presenter.configuration.newPage,''));&#13;
        textVoices.push(getTextVoiceObject(presenter.playerController.getPageTitle(),presenter.configuration.pageLangTag));&#13;
        presenter.speak(textVoices);&#13;
    };&#13;
&#13;
    presenter.playEnterText = function () {&#13;
        presenter.speak([getTextVoiceObject(presenter.configuration.enterText)]);&#13;
    };&#13;
&#13;
    presenter.playExitText = function () {&#13;
        presenter.speak([getTextVoiceObject(presenter.configuration.exitText)]);&#13;
    };&#13;
&#13;
    presenter.getModulesOrder = function () {&#13;
        return presenter.configuration.addOnsConfiguration.map(function (c) {&#13;
            return {&#13;
                id: c.id,&#13;
                area: c.area&#13;
            };&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            "show": presenter.show,&#13;
            "hide": presenter.hide,&#13;
            "speak": function(params) {&#13;
                    if (params.length === 2) {&#13;
                        presenter.speak(params[0], params[1]);&#13;
                    } else if (params.length === 1) {&#13;
                        presenter.speak(params[0]);&#13;
                    }&#13;
                },&#13;
            "playTitle": function(params) {&#13;
                    if (params.length === 3) {&#13;
                        presenter.playTitle(params[0],params[1],params[2]);&#13;
                    } else if (params.length === 2) {&#13;
                        presenter.playTitle(params[0],params[1]);&#13;
                    }&#13;
                },&#13;
            "playEnterText": presenter.playEnterText,&#13;
            "playExitText": presenter.playExitText,&#13;
            "getModulesOrder": presenter.getModulesOrder&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            addOnsConfiguration: presenter.configuration.addOnsConfiguration,&#13;
            enterText: presenter.configuration.enterText,&#13;
            exitText: presenter.configuration.exitText,&#13;
&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        presenter.configuration.addOnsConfiguration = parsedState.addOnsConfiguration;&#13;
        presenter.configuration.enterText = parsedState.enterText;&#13;
        presenter.configuration.exitText = parsedState.exitText;&#13;
&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.cancelSpeechSynthesis = function(){&#13;
        if (window.responsiveVoice) {&#13;
            window.responsiveVoice.cancel();&#13;
        }&#13;
        if ('speechSynthesis' in window) {&#13;
            window.speechSynthesis.cancel();&#13;
        }&#13;
        if(presenter.speechSynthInterval!==null){&#13;
            clearInterval(presenter.intervalId);&#13;
            presenter.intervalId = undefined;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.destroy = function () {&#13;
        presenter.$view[0].removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        presenter.cancelSpeechSynthesis();&#13;
        presenter.configuration = null;&#13;
        presenter.$view = null;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>