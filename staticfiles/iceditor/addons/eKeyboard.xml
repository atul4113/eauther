<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="eKeyboard" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property displayName="Work With" name="workWith" nameLabel="eKeyboard_property_work_with" type="text"/>
        <property displayName="Layout Type" name="layoutType" nameLabel="eKeyboard_property_layout_type" type="{Numeric, French (Special Characters), German (Special Characters), Italian (Special Characters), Spanish (Special Characters), Custom}"/>
        <property displayName="Custom Layout" isLocalized="true" name="customLayout" nameLabel="eKeyboard_property_custom_layout" type="text"/>
        <property displayName="Position My" name="positionMy" nameLabel="eKeyboard_property_position_my" type="string"/>
        <property displayName="Position At" name="positionAt" nameLabel="eKeyboard_property_position_at" type="string"/>
        <property displayName="Max Characters" name="maxCharacters" nameLabel="eKeyboard_property_max_characters" type="string"/>
        <property displayName="Don't Open On Focus" name="noOpenOnFocus" nameLabel="eKeyboard_property_no_open_on_focus" type="boolean"/>
        <property displayName="Lock Standard Keyboard Input" name="lockStandardKeyboardInput" nameLabel="eKeyboard_property_lock_standard_keyboard_input" type="boolean"/>
        <property displayName="Custom Display" isLocalized="true" name="customDisplay" nameLabel="eKeyboard_property_custom_display" type="text"/>
        <property displayName="Show Close Button" name="showCloseButton" nameLabel="eKeyboard_property_show_close_button" type="boolean"/>
	</model>
<css>/* keyboard - jQuery UI Widget */&#13;
.ui-keyboard { padding: .3em; position: absolute; left: 0; top: 0; z-index: 16000; }&#13;
.ui-keyboard-has-focus { z-index: 16001; }&#13;
.ui-keyboard div { font-size: 1.1em; }&#13;
.ui-keyboard-button { height: 2em; width: 2em; min-width: 1em; margin: .1em; cursor: pointer; overflow: hidden; line-height: 2em; -moz-user-focus: ignore; }&#13;
.ui-keyboard-button span { padding: 0; margin: 0; white-space:nowrap; display: inline-block; }&#13;
.ui-keyboard-button-endrow { clear: left; }&#13;
.ui-keyboard-widekey { min-width: 4em; width: auto; }&#13;
.ui-keyboard-space { width: 15em; }&#13;
.ui-keyboard-space span, .ui-keyboard-empty span { font: 0/0 a; text-shadow: none; color: transparent; } /* see http://nicolasgallagher.com/another-css-image-replacement-technique/ */&#13;
.ui-keyboard-preview-wrapper { text-align: center; }&#13;
.ui-keyboard-preview { text-align: left; margin: 0 0 3px 0; display: inline; width: 99%;} /* width is calculated in IE, since 99% = 99% full browser width =( */&#13;
.ui-keyboard-keyset { text-align: center; white-space: nowrap; }&#13;
.ui-keyboard-input { text-align: left; }&#13;
.ui-keyboard-input-current { -moz-box-shadow: 1px 1px 10px #00f; -webkit-box-shadow: 1px 1px 10px #00f; box-shadow: 1px 1px 10px #00f; }&#13;
.ui-keyboard-placeholder { color: #888; }&#13;
.ui-keyboard-nokeyboard { color: #888; border-color: #888; } /* disabled or readonly inputs, or use input[disabled='disabled'] { color: #f00; } */&#13;
.ui-keyboard-button.disabled { opacity: 0.5; filter: alpha(opacity=50); } /* used by the acceptValid option to make the accept button appear faded */&#13;
.ui-keyboard-spacer { display: inline-block; width: 1px; height: 0; }&#13;
&#13;
/* combo key styling - toggles diacritics on/off */&#13;
.ui-keyboard-button.ui-keyboard-combo.ui-state-default { border-color: #ffaf0f; }&#13;
&#13;
/* (in)valid inputs */&#13;
button.ui-keyboard-accept.ui-keyboard-valid-input { border-color: #0c0; background: #080; color: #fff; }&#13;
button.ui-keyboard-accept.ui-keyboard-valid-input:hover { background: #0a0; }&#13;
button.ui-keyboard-accept.ui-keyboard-invalid-input { border-color: #c00; background: #800; color: #fff; }&#13;
button.ui-keyboard-accept.ui-keyboard-invalid-input:hover { background: #a00; }&#13;
&#13;
/*** jQuery Mobile definitions ***/&#13;
/* jQuery Mobile styles - need wider buttons because of font size and text-overflow:ellipsis */&#13;
.ui-bar .ui-keyboard-button { width: 3em; display: inline-block; }&#13;
.ui-bar .ui-keyboard-widekey { width: 5.5em; }&#13;
.ui-bar .ui-keyboard-space { width: 15em; }&#13;
.ui-bar .ui-keyboard-space span { visibility: hidden; } /* hides the ellipsis */&#13;
.ui-bar .ui-keyboard-keyset { line-height: 0.5em; }&#13;
.ui-bar input.ui-input-text, .ui-bar textarea.ui-input-text { width: 95%; }&#13;
&#13;
/* over-ride padding set by mobile ui theme - needed because the mobile script wraps button text with several more spans */&#13;
.ui-bar .ui-btn-inner { height: 2em; padding: 0.2em 0; margin: 0; }&#13;
.ui-bar .ui-btn { margin: 0; font-size: 13px; } /* mobile default size is 13px */&#13;
&#13;
/* Media Queries (optimized for jQuery UI themes; may be slightly off in jQuery Mobile themes) */&#13;
/* 240 x 320 (small phone)  */&#13;
@media all and (max-width: 319px) {&#13;
    .ui-keyboard div { font-size: 9px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 12px; }&#13;
    /* I don't own an iPhone so I have no idea how small this really is... is it even clickable with your finger? */&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 9px; }&#13;
    .ui-bar .ui-keyboard-button { width: 1.8em; height: 2.5em; }&#13;
    .ui-bar .ui-keyboard-widekey { width: 4em; }&#13;
    .ui-bar .ui-keyboard-space { width: 8em; }&#13;
    .ui-bar .ui-btn-inner { height: 2.5em; padding: 0.3em 0; }&#13;
}&#13;
&#13;
/* 320 x 480 (iPhone)  */&#13;
@media all and (min-width: 320px) and (max-width: 479px) {&#13;
    .ui-keyboard div { font-size: 9px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 14px; }&#13;
    /* I don't own an iPhone so I have no idea how small this really is... is it even clickable with your finger? */&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 11px; }&#13;
    .ui-bar .ui-keyboard-button { width: 1.8em; height: 3em; }&#13;
    .ui-bar .ui-keyboard-widekey { width: 4.5em; }&#13;
    .ui-bar .ui-keyboard-space { width: 10em; }&#13;
    .ui-bar .ui-btn-inner { height: 3em; padding: 0.7em 0; }&#13;
}&#13;
&#13;
/* 480 x 640 (small tablet) */&#13;
@media all and (min-width: 480px) and (max-width: 767px) {&#13;
    .ui-keyboard div { font-size: 13px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 14px; }&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 10px; }&#13;
    .ui-bar .ui-keyboard-button { height: 2.5em; }&#13;
    .ui-bar .ui-btn-inner { height: 2.5em; padding: 0.5em 0; }&#13;
}&#13;
&#13;
.eKeyboard-close-button {&#13;
	border: 1px solid #cccccc;&#13;
  	background: #f6f6f6;&#13;
  	color: red;&#13;
    top: 0;&#13;
    left: 101%;&#13;
}&#13;
&#13;
.eKeyboard-open-button {&#13;
  	width: 33px;&#13;
  	height: 33px;&#13;
    background-color: transparent;&#13;
    border: 0px;&#13;
    background-position: center;&#13;
    background-image: url("resources/eKeyboard.png");&#13;
    background-repeat: no-repeat;&#13;
    background-size: 32px 32px;&#13;
}&#13;
&#13;
&#13;
</css><view>&lt;div class="eKeyboard-wrapper"&gt;&#13;
    &lt;div class="eKeyboard-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="eKeyboard-wrapper"&gt;&#13;
    &lt;div class="eKeyboard-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddoneKeyboard_create(){&#13;
&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.playerController = null;&#13;
    presenter.eventBus = null;&#13;
    presenter.display = null;&#13;
    presenter.isLoaded = false;&#13;
    presenter.functionsQueue = [];&#13;
&#13;
    var keyboardIsVisible = true;&#13;
    var closeButtonElement = null;&#13;
    var openButtonElement = null;&#13;
    var lastClickedElement = null;&#13;
    var movedInput = false;&#13;
    var escClicked = false;&#13;
&#13;
&#13;
    presenter.LAYOUT_TO_LANGUAGE_MAPPING = {&#13;
        'french (special characters)' : "{ \&#13;
            'default': ['\u00e0 \u00e2 \u00e7 \u00e8 \u00e9 \u00ea \u00ee \u00ef \u00f4 \u00f9 \u0153 \u00fb \u00e6 \u00eb {shift}'], \&#13;
            'shift': ['\u00c0 \u00c2 \u00c7 \u00c8 \u00c9 \u00ca \u00cb \u00ce \u00cf \u00d4 \u00d9 \u00db \u00c6 \u0152 {shift}'] \&#13;
        }",&#13;
        'german (special characters)' : "{ \&#13;
            'default': ['\u00e4 \u00f6 \u00fc \u00df {shift}'], \&#13;
            'shift': ['\u00c4 \u00d6 \u00dc {empty} {shift}'] \&#13;
        }",&#13;
        'spanish (special characters)' : "{ \&#13;
            'default': ['\u00e1 \u00e9 \u00ed \u00f3 \u00fa \u00f1 \u00e7 \u00fc \u00a1 \u00bf \u00ba \u00aa {shift}'], \&#13;
            'shift': ['\u00c1 \u00c9 \u00cd \u00d3 \u00da \u00d1 \u00c7 \u00dc {empty} {empty} {empty} {empty} {shift}'] \&#13;
        }",&#13;
        'italian (special characters)' : "{ \&#13;
            'default': ['\u00e0 \u00e8 \u00e9 \u00ec \u00f2 \u00f9 {shift}'], \&#13;
            'shift': ['\u00c0 \u00c8 \u00c9 \u00cc \u00d2 \u00d9 {shift}'] \&#13;
        }"&#13;
    };&#13;
&#13;
    function touchStartDecorator(func, element) {&#13;
        $(element).on('click', function (ev) {&#13;
            ev.preventDefault();&#13;
            ev.stopPropagation();&#13;
&#13;
            func();&#13;
        });&#13;
    }&#13;
&#13;
    presenter.initializeCloseButton = function AddoneKeyboard_initializeCloseButton() {&#13;
        closeButtonElement = document.createElement('button');&#13;
        closeButtonElement.className = 'eKeyboard-close-button';&#13;
        closeButtonElement.style.position = 'absolute';&#13;
        closeButtonElement.innerHTML = '&lt;span&gt;\u2716&lt;/span&gt;';&#13;
        closeButtonElement.style.display = 'none';&#13;
&#13;
        $(presenter.keyboardWrapper).append(closeButtonElement);&#13;
&#13;
        touchStartDecorator(closeButtonCallBack, closeButtonElement);&#13;
    };&#13;
&#13;
    function initializeOpenButton() {&#13;
        openButtonElement = document.createElement('button');&#13;
        openButtonElement.className = 'eKeyboard-open-button';&#13;
        openButtonElement.style.display = 'none';&#13;
        openButtonElement.style.zindex = 'none';&#13;
        $(openButtonElement).on('mousedown', function (ev) {&#13;
            ev.preventDefault();&#13;
            ev.stopPropagation();&#13;
            showOpenButtonCallback();&#13;
        });&#13;
&#13;
        $("body").append(openButtonElement);&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
        presenter.eventBus.addEventListener('PageLoaded', this);&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function(eventName) {&#13;
        if (eventName == 'PageLoaded') {&#13;
            presenter.pageLoadedDeferred.resolve();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateType = function(rawType) {&#13;
        if (rawType == 'Numeric' || rawType.length == 0) {&#13;
            return 'num';&#13;
        }&#13;
&#13;
        return rawType.toLowerCase();&#13;
    };&#13;
&#13;
    presenter.validateMaxCharacters = function(rawMaxCharacters) {&#13;
        if (rawMaxCharacters.length == 0) {&#13;
            return {&#13;
                'isError' : false,&#13;
                'value' : false&#13;
            };&#13;
        }&#13;
&#13;
        if ( !(/\d+/.test(rawMaxCharacters)) ) {&#13;
            return {&#13;
                'isError' : true,&#13;
                'errorCode' : 'E04'&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            'isError' : false,&#13;
            'value' : parseInt(rawMaxCharacters, 10)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'E01' : 'The position is wrong. See documentation for more details.',&#13;
        'E02' : 'Module ID not found.',&#13;
        'E03' : 'The module you provided has no getView method implemented.',&#13;
        'E04' : 'Max Characters must be a digit or empty string (unlimited).'&#13;
    };&#13;
&#13;
    presenter.validatePosition = function(rawPosition, isMy) {&#13;
        if (rawPosition.length == 0) {&#13;
            return {&#13;
                isError: false,&#13;
                value: isMy ? 'left center' : 'right center'&#13;
            }&#13;
        }&#13;
&#13;
        var possibilitiesOnTheLeft = ['left', 'center', 'right'],&#13;
            possibilitiesOnTheRight = ['top', 'center', 'bottom'],&#13;
            splitted = rawPosition.split(' ');&#13;
&#13;
        if (splitted.length == 2&#13;
            &amp;&amp; possibilitiesOnTheLeft.indexOf(splitted[0]) &gt;= 0&#13;
            &amp;&amp; possibilitiesOnTheRight.indexOf(splitted[1]) &gt;= 0&#13;
            ) {&#13;
&#13;
            return {&#13;
                isError: false,&#13;
                value: rawPosition&#13;
            }&#13;
&#13;
        } else {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: 'E01'&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateOffsetData = function(positionMy, positionAt) {&#13;
        var splittedMy = positionMy.split(' '),&#13;
            splittedAt = positionAt.split(' ');&#13;
&#13;
        if (splittedMy[1] == 'bottom' &amp;&amp; splittedAt[1] == 'top') {&#13;
            return {&#13;
                orientation: 'horizontal',&#13;
                directionSign: '-',&#13;
                value: '0 -10'&#13;
            }&#13;
        }&#13;
&#13;
        if (splittedMy[0] == 'left' &amp;&amp; splittedAt[0] == 'right') {&#13;
            return {&#13;
                orientation: 'vertical',&#13;
                directionSign: '',&#13;
                value: '10 0'&#13;
            };&#13;
        }&#13;
&#13;
        if (splittedMy[1] == 'top' &amp;&amp; splittedAt[1] == 'bottom') {&#13;
            return {&#13;
                orientation: 'horizontal',&#13;
                directionSign: '',&#13;
                value : '0 10'&#13;
            };&#13;
        }&#13;
&#13;
        if (splittedMy[0] == 'right' &amp;&amp; splittedAt[0] == 'left') {&#13;
            return {&#13;
                orientation: 'vertical',&#13;
                directionSign: '-',&#13;
                value: '-10 0'&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            orientation: 'none',&#13;
            directionSign: '',&#13;
            value : ''&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        runLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model, isPreview) {&#13;
        var workWithModules = Helpers.splitLines(model['workWith']),&#13;
            workWithViews = [],&#13;
            layoutType = presenter.validateType(model['layoutType']),&#13;
            customLayout = model['customLayout'],&#13;
            maxCharacters = presenter.validateMaxCharacters(model['maxCharacters']),&#13;
            positionMy = presenter.validatePosition(model['positionMy'], true),&#13;
            positionAt = presenter.validatePosition(model['positionAt'], false),&#13;
            workWithIsValid = true,&#13;
            workWithErrorCode = '',&#13;
            customDisplay = model['customDisplay'];&#13;
&#13;
        if (!isPreview) {&#13;
            $.each(workWithModules, function() {&#13;
                var module = presenter.playerController.getModule(this.toString()),&#13;
                    moduleNotFound = false,&#13;
                    getViewNotImplemented = false;&#13;
&#13;
                if (module) {&#13;
                    if ( module.getView() ) {&#13;
                        workWithViews.push( module.getView() );&#13;
                    } else {&#13;
                        getViewNotImplemented = true;&#13;
                        return false;&#13;
                    }&#13;
                } else {&#13;
                    moduleNotFound = true;&#13;
                    return false;&#13;
                }&#13;
&#13;
                if (getViewNotImplemented || moduleNotFound) {&#13;
                    workWithIsValid = false;&#13;
                    workWithErrorCode = moduleNotFound ? 'E02' : 'E03';&#13;
                    return false;&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        if (!workWithIsValid) {&#13;
            return {&#13;
                'isError' : true,&#13;
                'errorCode' : workWithErrorCode&#13;
            }&#13;
        }&#13;
&#13;
        if (maxCharacters.isError) {&#13;
            return {&#13;
                'isError' : true,&#13;
                'errorCode' : maxCharacters.errorCode&#13;
            }&#13;
        }&#13;
&#13;
        if (positionMy.isError) {&#13;
            return {&#13;
                'isError' : true,&#13;
                'errorCode' : positionMy.errorCode&#13;
            }&#13;
        }&#13;
&#13;
        if (positionAt.isError) {&#13;
            return {&#13;
                'isError' : true,&#13;
                'errorCode' : positionAt.errorCode&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.LAYOUT_TO_LANGUAGE_MAPPING[layoutType] != undefined) {&#13;
            customLayout = presenter.LAYOUT_TO_LANGUAGE_MAPPING[layoutType];&#13;
            layoutType = 'custom';&#13;
        }&#13;
&#13;
        if (typeof(customDisplay) == 'undefined') {&#13;
            customDisplay = '';&#13;
        }&#13;
        return {&#13;
            'ID': model["ID"],&#13;
            'isError' : false,&#13;
            'workWithViews' : workWithViews,&#13;
            'layoutType' : layoutType,&#13;
            'customLayout' : customLayout,&#13;
            'positionAt' : positionAt,&#13;
            'positionMy' : positionMy,&#13;
            'maxCharacters' : maxCharacters.value,&#13;
            'offset' : presenter.validateOffsetData(positionMy.value, positionAt.value),&#13;
            'openOnFocus' : !ModelValidationUtils.validateBoolean(model['noOpenOnFocus']),&#13;
            'lockInput' : ModelValidationUtils.validateBoolean(model['lockStandardKeyboardInput']),&#13;
            'customDisplay' : customDisplay,&#13;
            'showCloseButton': ModelValidationUtils.validateBoolean(model['showCloseButton'])&#13;
        }&#13;
    };&#13;
&#13;
    presenter.removeEventListeners = function () {&#13;
        presenter.configuration.$inputs.each(function (index, element) {&#13;
            element.removeEventListener('mousedown', presenter.focusOnMouseDown);&#13;
            element.removeEventListener('focus', presenter.openEKeyboardOnFocus);&#13;
            element.removeEventListener('forceClick', presenter.openEKeyboardOnForceClick);&#13;
            element.removeEventListener('keyup', presenter.onESCHideKeyboard);&#13;
            element.removeEventListener('change', presenter.moveToNextGap);&#13;
            element.removeEventListener('paste', presenter.moveToNextGap);&#13;
            element.removeEventListener('keyup', presenter.moveToNextGap);&#13;
            element.removeEventListener('focusout', focusoutCallBack);&#13;
        });&#13;
    };&#13;
&#13;
    function runLogic(view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.view = view;&#13;
        presenter.isPreview = isPreview;&#13;
        presenter.isShowCloseButton = false;&#13;
&#13;
        presenter.pageLoadedDeferred = new $.Deferred();&#13;
        presenter.pageLoaded = presenter.pageLoadedDeferred.promise();&#13;
&#13;
        presenter.keyboardWrapper = document.createElement("div");&#13;
        presenter.keyboardWrapper.className = "ui-ekeyboard-wrapper";&#13;
        $(document.body).append(presenter.keyboardWrapper);&#13;
&#13;
        initializeOpenButton();&#13;
        presenter.initializeCloseButton();&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved_eKeyboard (ev) {&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
&#13;
        var mathJaxDeferred = new jQuery.Deferred(),&#13;
            mathJaxProcessEnded = mathJaxDeferred.promise();&#13;
&#13;
        MathJax.Hub.Register.MessageHook("End Process", function (message) {&#13;
            if ($(message[1]).hasClass('ic_page')) {&#13;
                if(mathJaxDeferred.state() != 'resolved'){&#13;
                    mathJaxDeferred.resolve();&#13;
                }&#13;
            }&#13;
&#13;
            if ($(message[1]).hasClass('ic_popup_page')) {&#13;
                if(mathJaxDeferred.state() != 'resolved'){&#13;
                    mathJaxDeferred.resolve();&#13;
                }&#13;
            }&#13;
        });&#13;
&#13;
        $.when(presenter.pageLoaded, mathJaxProcessEnded).then(function() {&#13;
            presenter.configuration = presenter.validateModel(model, isPreview);&#13;
            presenter.configuration.$inputs = $(presenter.configuration.workWithViews).find('input');&#13;
&#13;
            if (presenter.configuration.isError) {&#13;
                DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
                return;&#13;
            }&#13;
&#13;
            if (!isPreview) {&#13;
                if (presenter.configuration.customLayout.length &gt; 0) {&#13;
                    try {&#13;
                        eval('presenter.configuration.customLayout = ' + presenter.configuration.customLayout);&#13;
                    } catch (e) {&#13;
                        presenter.ERROR_CODES['evaluationError'] = e.message;&#13;
                        DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'evaluationError');&#13;
                    }&#13;
                }&#13;
&#13;
                if (presenter.configuration.customDisplay.length &gt; 0) {&#13;
                    try {&#13;
                        eval('presenter.configuration.customDisplay = ' + presenter.configuration.customDisplay);&#13;
                    } catch(e) {&#13;
                        presenter.ERROR_CODES['evaluationError'] = e.message;&#13;
                        DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'evaluationError');&#13;
                    }&#13;
                }&#13;
                presenter.configuration.customLayout.id = new Date().getTime();&#13;
&#13;
                var defaultDisplay = {&#13;
                    a      : '\u2714:Accept (Shift-Enter)', // check mark - same action as accept&#13;
                    accept : 'Accept:Accept (Shift-Enter)',&#13;
                    alt    : 'AltGr:Alternate Graphemes',&#13;
                    b      : '\u2190:Backspace',    // Left arrow (same as &amp;larr;)&#13;
                    bksp   : 'Bksp:Backspace',&#13;
                    c      : '\u2716:Cancel (Esc)', // big X, close - same action as cancel&#13;
                    cancel : 'Cancel:Cancel (Esc)',&#13;
                    clear  : 'C:Clear',             // clear num pad&#13;
                    combo  : '\u00f6:Toggle Combo Keys',&#13;
                    dec    : '.:Decimal',           // decimal point for num pad (optional), change '.' to ',' for European format&#13;
                    e      : '\u21b5:Enter',        // down, then left arrow - enter symbol&#13;
                    enter  : 'Enter:Enter',&#13;
                    left   : '\u2190',              // left arrow (move caret)&#13;
                    lock   : '\u21ea Lock:Caps Lock', // caps lock&#13;
                    next   : 'Next',&#13;
                    prev   : 'Prev',&#13;
                    right  : '\u2192',              // right arrow (move caret)&#13;
                    s      : '\u21e7:Shift',        // thick hollow up arrow&#13;
                    shift  : 'CapsLock:CapsLock',&#13;
                    sign   : '\u00b1:Change Sign',  // +/- sign for num pad&#13;
                    space  : '&amp;nbsp;:Space',&#13;
                    t      : '\u21e5:Tab',          // right arrow to bar (used since this virtual keyboard works with one directional tabs)&#13;
                    tab    : '\u21e5 Tab:Tab'       // \u21b9 is the true tab symbol (left &amp; right arrows)&#13;
                };&#13;
&#13;
                var customDisplay = presenter.configuration.customDisplay;&#13;
                presenter.display = $.extend(defaultDisplay, customDisplay);&#13;
&#13;
                if (MobileUtils.isMobileUserAgent(navigator.userAgent) &amp;&amp; presenter.configuration.lockInput) {&#13;
                    $('input').addClass('ui-keyboard-lockedinput');&#13;
                    $('input').attr("readonly", true);&#13;
                }&#13;
&#13;
                presenter.removeEventListeners();&#13;
&#13;
                presenter.connectHandlers();&#13;
            }&#13;
            for (var i = 0; i &lt; presenter.functionsQueue.length; i++) {&#13;
                presenter.functionsQueue[i]();&#13;
            }&#13;
            presenter.isLoaded = true;&#13;
        });&#13;
    }&#13;
&#13;
    /**&#13;
     * Adds handlers to all input elements with which eKeyboard works&#13;
     */&#13;
&#13;
    presenter.connectHandlers = function AddoneKeyboard_connectHandlers() {&#13;
        presenter.configuration.$inputs.each(&#13;
            function (index, element) {&#13;
                if (DevicesUtils.isInternetExplorer()) {&#13;
                    element.addEventListener('mousedown', presenter.focusOnMouseDown);&#13;
                }&#13;
&#13;
                element.addEventListener('focus', presenter.openEKeyboardOnFocus);&#13;
                element.addEventListener('forceClick', presenter.openEKeyboardOnForceClick);&#13;
                element.addEventListener('keyup', presenter.onESCHideKeyboard);&#13;
&#13;
                if (presenter.configuration.maxCharacters !== false) {&#13;
                    element.addEventListener('change', presenter.moveToNextGap);&#13;
                    element.addEventListener('paste', presenter.moveToNextGap);&#13;
                    element.addEventListener('keyup', presenter.moveToNextGap);&#13;
                }&#13;
&#13;
                //This is after setState because validateModel is in promise.&#13;
                if (!keyboardIsVisible) {&#13;
                    element.addEventListener('focusout', focusoutCallBack);&#13;
                }&#13;
            });&#13;
    };&#13;
&#13;
    presenter.focusOnMouseDown = function AddoneKeyboard_focusOnMouseDown () {&#13;
        $(this).focus();&#13;
    };&#13;
&#13;
    presenter.openEKeyboardOnFocus = function AddoneKeyboard_openEKeyboardOnFocus () {&#13;
        lastClickedElement = this;&#13;
        if (!keyboardIsVisible) {&#13;
            if ($(this).data('keyboard') !== undefined) {&#13;
                $(this).data('keyboard').destroy();&#13;
            }&#13;
            showOpenButton();&#13;
        } else {&#13;
            if (MobileUtils.isMobileUserAgent(navigator.userAgent) &amp;&amp; presenter.configuration.lockInput) {&#13;
                // hides native keyboard&#13;
                document.activeElement.blur();&#13;
            }&#13;
            presenter.createEKeyboard(this, presenter.display);&#13;
            $(this).trigger('showKeyboard');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.openEKeyboardOnForceClick = function AddoneKeyboard_openEKeyboardOnForceClick() {&#13;
        if (presenter.configuration.openOnFocus) {&#13;
            $(this).data('keyboard').reveal();&#13;
            if ($(".ic_popup_page").length == 0) {&#13;
                $(this).data('keyboard').startup();&#13;
            }&#13;
        } else {&#13;
            $(this).focus();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onESCHideKeyboard = function AddoneKeyboard_onESCHideKeyboard(e) {&#13;
        if (e.keyCode === 27) {&#13;
            onEscClick(this);&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
            return false;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.moveToNextGap = function AddoneKeyboard_moveToNextGap() {&#13;
        if ($(this).val().length &gt;= presenter.configuration.maxCharacters) {&#13;
            var self = this;&#13;
            $(this).val($(this).val().substring(0, presenter.configuration.maxCharacters));&#13;
&#13;
            if ($(this).data('keyboard') !== undefined) {&#13;
                //Fix bug with events&#13;
                setTimeout(function () {&#13;
                    $(self).data('keyboard').switchInput(true, true);&#13;
                }, 0);&#13;
            } else {&#13;
                lastClickedElement = this;&#13;
                movedInput = true;&#13;
                getNextFocusableElement(this, true).focus();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.clickedOutsideCallback = function AddoneKeyboard_clickedOutsideCallback(event) {&#13;
        // shouldn't hide keyboard when current input was clicked&#13;
        if (event.target === lastClickedElement) return;&#13;
&#13;
        var wrapper = $(presenter.keyboardWrapper);&#13;
&#13;
        // if click outside of wrapper or it's descendant, hide keyboard&#13;
        if (!wrapper.is(event.target) &amp;&amp; wrapper.has(event.target).length === 0) {&#13;
            presenter.hideKeyboard();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideKeyboard = function () {&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
&#13;
        $(closeButtonElement).hide();&#13;
        $(lastClickedElement).removeAttr("readonly");&#13;
        var keyboard = $(lastClickedElement).data('keyboard');&#13;
        if (keyboard !== undefined) {&#13;
            keyboard.accept();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createEKeyboard = function (element, display) {&#13;
        if ($(element).data('keyboard') !== undefined) {&#13;
            return;&#13;
        }&#13;
&#13;
        $(element).keyboard({&#13;
            // *** choose layout ***&#13;
            layout: presenter.configuration.layoutType,&#13;
            customLayout: presenter.configuration.customLayout,&#13;
            position: {&#13;
                of : null, // optional - null (attach to input/textarea) or a jQuery object (attach elsewhere)&#13;
                my : presenter.configuration.positionMy.value,&#13;
                at : presenter.configuration.positionAt.value,&#13;
                at2 : presenter.configuration.positionAt.value,&#13;
                offset : presenter.configuration.offset.value,&#13;
                collision: 'flip'&#13;
            },&#13;
&#13;
                    // preview added above keyboard if true, original input/textarea used if false&#13;
                    usePreview: false,&#13;
&#13;
                    // if true, the keyboard will always be visible&#13;
                    alwaysOpen: false,&#13;
&#13;
                    // give the preview initial focus when the keyboard becomes visible&#13;
                    initialFocus: presenter.configuration.lockInput,&#13;
&#13;
                    // if true, keyboard will remain open even if the input loses focus.&#13;
                    stayOpen: true,&#13;
&#13;
                    // *** change keyboard language &amp; look ***&#13;
                    display: display,&#13;
&#13;
                    // Message added to the key title while hovering, if the mousewheel plugin exists&#13;
                    wheelMessage: 'Use mousewheel to see other keys',&#13;
&#13;
                    css: {&#13;
                        input          : '', //'ui-widget-content ui-corner-all', // input &amp; preview&#13;
                        container      : 'ui-widget-content ui-widget ui-corner-all ui-helper-clearfix', // keyboard container&#13;
                        buttonDefault  : 'ui-state-default ui-corner-all', // default state&#13;
                        buttonHover    : 'ui-state-hover',  // hovered button&#13;
                        buttonAction   : 'ui-state-active', // Action keys (e.g. Accept, Cancel, Tab, etc); replaces "actionClass"&#13;
                        buttonDisabled : 'ui-state-disabled' // used when disabling the decimal button {dec}&#13;
                    },&#13;
&#13;
                    // *** Useability ***&#13;
                    // Auto-accept content when clicking outside the keyboard (popup will close)&#13;
                    autoAccept: true,&#13;
&#13;
                    // Prevents direct input in the preview window when true&#13;
                    lockInput: presenter.configuration.lockInput,&#13;
&#13;
                    // Prevent keys not in the displayed keyboard from being typed in&#13;
                    restrictInput: false,&#13;
&#13;
                    // Check input against validate function, if valid the accept button is clickable;&#13;
                    // if invalid, the accept button is disabled.&#13;
                    acceptValid: true,&#13;
&#13;
                    // Use tab to navigate between input fields&#13;
                    tabNavigation: true,&#13;
&#13;
                    // press enter (shift-enter in textarea) to go to the next input field&#13;
                    enterNavigation : true,&#13;
                    // mod key options: 'ctrlKey', 'shiftKey', 'altKey', 'metaKey' (MAC only)&#13;
                    enterMod : 'altKey', // alt-enter to go to previous; shift-alt-enter to accept &amp; go to previous&#13;
&#13;
                    // if true, the next button will stop on the last keyboard input/textarea; prev button stops at first&#13;
                    // if false, the next button will wrap to target the first input/textarea; prev will go to the last&#13;
                    stopAtEnd : false,&#13;
&#13;
                    // Set this to append the keyboard immediately after the input/textarea it is attached to.&#13;
                    // This option works best when the input container doesn't have a set width and when the&#13;
                    // "tabNavigation" option is true&#13;
                    appendLocally: false,&#13;
&#13;
            appendTo: presenter.keyboardWrapper,&#13;
&#13;
                    // If false, the shift key will remain active until the next key is (mouse) clicked on;&#13;
                    // if true it will stay active until pressed again&#13;
                    stickyShift: true,&#13;
&#13;
                    // Prevent pasting content into the area&#13;
                    preventPaste: false,&#13;
&#13;
                    // Set the max number of characters allowed in the input, setting it to false disables this option&#13;
                    //maxLength: presenter.configuration.maxCharacters,&#13;
&#13;
                    // Mouse repeat delay - when clicking/touching a virtual keyboard key, after this delay the key&#13;
                    // will start repeating&#13;
                    repeatDelay: 500,&#13;
&#13;
                    // Mouse repeat rate - after the repeatDelay, this is the rate (characters per second) at which the&#13;
                    // key is repeated. Added to simulate holding down a real keyboard key and having it repeat. I haven't&#13;
                    // calculated the upper limit of this rate, but it is limited to how fast the javascript can process&#13;
                    // the keys. And for me, in Firefox, it's around 20.&#13;
                    repeatRate: 20,&#13;
&#13;
                    // resets the keyboard to the default keyset when visible&#13;
                    resetDefault: false,&#13;
&#13;
                    // Event (namespaced) on the input to reveal the keyboard. To disable it, just set it to ''.&#13;
                    openOn: presenter.configuration.openOnFocus ? 'showKeyboard' : '',&#13;
&#13;
                    // When the character is added to the input&#13;
                    keyBinding: 'touchend mousedown',&#13;
&#13;
                    // combos (emulate dead keys : http://en.wikipedia.org/wiki/Keyboard_layout#US-International)&#13;
                    // if user inputs `a the script converts it to Ă , ^o becomes Ă´, etc.&#13;
                    useCombos: false,&#13;
&#13;
                    // if true, keyboard will not close if you press escape.&#13;
                    ignoreEsc : true,&#13;
&#13;
                    autoAcceptOnEsc : false,&#13;
                    // *** Methods ***&#13;
                    // Callbacks - add code inside any of these callback functions as desired&#13;
                    initialized: function (e, keyboard, el) {&#13;
                    },&#13;
                    beforeVisible: function (e, keyboard, el) {&#13;
                        if (!keyboard['$keyboard'].parent().hasClass('html')) {&#13;
                            var dialogBox = keyboard['$keyboard'].parent().find('.gwt-DialogBox');&#13;
                            dialogBox.append(keyboard['$keyboard']);&#13;
                        }&#13;
&#13;
                        var parent = keyboard['$keyboard'].parent(),&#13;
                            popup = parent.find('.ic_popup');&#13;
&#13;
                        if (popup.length &gt; 0) {&#13;
                            popup.append(keyboard['$keyboard']);&#13;
                        }&#13;
                    },&#13;
                    visible: function (e, keyboard, el) {&#13;
                        var isVisibleInViewPort = getIsVisibleInViewPort(keyboard['$keyboard']);&#13;
                        if (!isVisibleInViewPort) {&#13;
                            return;&#13;
                        }&#13;
&#13;
                        if (!isVisibleInViewPort.vertical || !isVisibleInViewPort.horizontal) {&#13;
                            shiftKeyboard(keyboard, isVisibleInViewPort);&#13;
                        }&#13;
&#13;
                        keyboard['$keyboard'].draggable({&#13;
                            drag: function () {&#13;
                                $(closeButtonElement).position({&#13;
                                    my:        "left top",&#13;
                                    at:        "right top",&#13;
                                    of:         keyboard['$keyboard'],&#13;
                                    collision: 'fit'&#13;
                                });&#13;
                            },&#13;
                            stop: function () {&#13;
                                $.ui.ddmanager.current = null;&#13;
                            }&#13;
                        });&#13;
&#13;
                        var $keyboard = keyboard['$keyboard'];&#13;
                        var position = $keyboard.position();&#13;
&#13;
                        var widthMargin = ($keyboard.outerWidth(true) -  $keyboard.innerWidth()) / 2;&#13;
                        var width = $keyboard.outerWidth() + widthMargin;&#13;
&#13;
                        var heightMargin = ($keyboard.outerHeight(true) -  $keyboard.innerHeight()) / 2;&#13;
&#13;
                        $(closeButtonElement).css({&#13;
                            top: position.top + heightMargin + 'px',&#13;
                            left: position.left + width + 'px'&#13;
                        });&#13;
&#13;
                        showCloseButton();&#13;
&#13;
                        document.addEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
                    },&#13;
                    change: function (e, keyboard, el) {&#13;
                        var api = $(lastClickedElement).data('keyboard');&#13;
&#13;
                        //Fixing the issue where if a key contains word 'meta' it will be treated as a meta key&#13;
                        if (api.last.key &amp;&amp; api.last.key.indexOf('meta') != -1&#13;
                            &amp;&amp; presenter.configuration.customLayout[api.last.key] == null) {&#13;
                            keyboard.insertText(api.last.key);&#13;
                        }&#13;
&#13;
                        var event = new Event('change');&#13;
                        el.dispatchEvent(event);&#13;
&#13;
                    },&#13;
                    beforeClose: function(e, keyboard, el, accepted) {&#13;
                        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
                        $(closeButtonElement).hide();&#13;
                    },&#13;
                    accepted: function(e, keyboard, el) {},&#13;
                    canceled: function(e, keyboard, el) {},&#13;
                    hidden: function(e, keyboard, el) {},&#13;
&#13;
                    switchInput : function(keyboard, goToNext, isAccepted){&#13;
                        var base = keyboard, kb, stopped = false,&#13;
                            all = $('input, textarea').filter(':enabled'),&#13;
                            indx = all.index(base.$el) + (goToNext ? 1 : -1);&#13;
&#13;
                        if (indx &gt; all.length - 1) {&#13;
                            stopped = keyboard.stopAtEnd;&#13;
                            indx = 0; // go to first input&#13;
                        }&#13;
                        if (indx &lt; 0) {&#13;
                            stopped = keyboard.stopAtEnd;&#13;
                            indx = all.length - 1; // stop or go to last&#13;
                        }&#13;
                			if (!stopped) {&#13;
                				if (!base.close(isAccepted)) {&#13;
                                    return;&#13;
                                }&#13;
                                if (presenter.addonIsWorkingWithElement(all.eq(indx))) {&#13;
                                        presenter.createEKeyboard(all.eq(indx), display);&#13;
                                }&#13;
                                if (keyboardIsVisible) {&#13;
                                    all.eq(indx).trigger('forceClick');&#13;
                                }&#13;
                                if($(".ic_popup_page").length == 0){&#13;
                                    all.eq(indx).focus();&#13;
                                }&#13;
                			}&#13;
&#13;
                        return false;&#13;
                	},&#13;
                    // this callback is called just before the "beforeClose" to check the value&#13;
                    // if the value is valid, return true and the  will continue as it should&#13;
                    // (close if not always open, etc)&#13;
                    // if the value is not value, return false and the clear the keyboard value&#13;
                    // ( like this "keyboard.$preview.val('');" ), if desired&#13;
                    // The validate function is called after each input, the "isClosing" value will be false;&#13;
                    // when the accept button is clicked, "isClosing" is true&#13;
                    validate: function (keyboard, value, isClosing) {&#13;
                        return true;&#13;
                    }&#13;
                });&#13;
                $(lastClickedElement).trigger('forceClick');&#13;
            };&#13;
&#13;
    function getNextFocusableElement (element, next) {&#13;
        var all = $('input, textarea').filter(':enabled');&#13;
        var indx = all.index(element) + (next ? 1 : -1);&#13;
&#13;
        if (indx &gt; all.length - 1) {&#13;
            indx = 0; // go to first input&#13;
        }&#13;
        if (indx &lt; 0) {&#13;
            indx = all.length - 1; // stop or go to last&#13;
        }&#13;
        return all.eq(indx);&#13;
&#13;
    }&#13;
&#13;
    presenter.addonIsWorkingWithElement = function (element) {&#13;
        return ($(presenter.configuration.workWithViews).find(element).length != 0);&#13;
    };&#13;
&#13;
    function asyncFunctionDecorator(func) {&#13;
        if (presenter.isLoaded) {&#13;
            func();&#13;
        } else {&#13;
            presenter.functionsQueue.push(func);&#13;
        }&#13;
    }&#13;
&#13;
    function hideOpenButton() {&#13;
        openButtonElement.style.display = 'none';&#13;
    }&#13;
&#13;
    function focusoutCallBack(ev) {&#13;
        if (!keyboardIsVisible &amp;&amp; !movedInput) {&#13;
            hideOpenButton();&#13;
        }&#13;
        movedInput = false;&#13;
        ev.preventDefault();&#13;
    }&#13;
&#13;
    function showButtonDecorator(func) {&#13;
        if (presenter.configuration.showCloseButton || presenter.isShowCloseButton) {&#13;
            func();&#13;
        }&#13;
    }&#13;
&#13;
    function showCloseButton() {&#13;
        showButtonDecorator(function () {&#13;
            $(closeButtonElement).show();&#13;
        });&#13;
    }&#13;
&#13;
    function closeButtonCallBack() {&#13;
        presenter.disable();&#13;
&#13;
        $(lastClickedElement).focus();&#13;
        $(lastClickedElement).click();&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
        $(closeButtonElement).hide();&#13;
    }&#13;
&#13;
    function showOpenButton() {&#13;
        showButtonDecorator(function showOpenButtonToDecorator() {&#13;
            openButtonElement.style.display = 'block';&#13;
            actualizeOpenButtonPosition($(lastClickedElement));&#13;
        });&#13;
    }&#13;
&#13;
    function showOpenButtonCallback() {&#13;
        hideOpenButton();&#13;
&#13;
        presenter.enable();&#13;
&#13;
        escClicked = false;&#13;
&#13;
        document.activeElement.blur();&#13;
&#13;
        $(lastClickedElement).click();&#13;
        $(lastClickedElement).focus();&#13;
        $(lastClickedElement).trigger('showKeyboard');&#13;
    }&#13;
&#13;
    function actualizeOpenButtonPosition(element) {&#13;
        $(openButtonElement).position({&#13;
            of: element,&#13;
            my: presenter.configuration.positionMy.value,&#13;
            at: presenter.configuration.positionAt.value,&#13;
            at2: presenter.configuration.positionAt.value,&#13;
            offset: presenter.configuration.offset.value,&#13;
            collision: 'flip'&#13;
        });&#13;
    }&#13;
&#13;
    function shiftKeyboard(keyboard, isVisibleInViewPort) {&#13;
        if (!isVisibleInViewPort.horizontal) {&#13;
            var currentLeft = parseInt(keyboard['$keyboard'].css('left'), 10);&#13;
            keyboard['$keyboard'].css('left', currentLeft + parseInt(isVisibleInViewPort.horizontalSign + '10', 10));&#13;
        }&#13;
        if (!isVisibleInViewPort.vertical) {&#13;
            var currentTop = parseInt(keyboard['$keyboard'].css('top'), 10);&#13;
            keyboard['$keyboard'].css('top', currentTop + parseInt(isVisibleInViewPort.verticalSign + '10', 10));&#13;
        }&#13;
    }&#13;
&#13;
    function getIsVisibleInViewPort(element) {&#13;
        var $window = $(window);&#13;
&#13;
        if (this.length &lt; 1)&#13;
            return;&#13;
&#13;
        if ($(element).length == 0) {&#13;
            return;&#13;
        }&#13;
&#13;
        var $element = $(element),&#13;
            vpWidth = $window.width(),&#13;
            vpHeight = $window.height(),&#13;
            viewTop = $window.scrollTop(),&#13;
            viewBottom = viewTop + vpHeight,&#13;
            viewLeft = $window.scrollLeft(),&#13;
            viewRight = viewLeft + vpWidth,&#13;
            offset = $element.offset(),&#13;
            _top = offset.top,&#13;
            _bottom = _top + $element.height(),&#13;
            _left = offset.left,&#13;
            _right = _left + $element.width();&#13;
&#13;
        return {&#13;
            vertical: ((_bottom &lt;= viewBottom) &amp;&amp; (_top &gt;= viewTop)),&#13;
            horizontal: ((_right &lt;= viewRight) &amp;&amp; (_left &gt;= viewLeft)),&#13;
            verticalSign: _bottom &lt;= viewBottom ? '' : '-',&#13;
            horizontalSign: _right &lt;= viewRight ? '' : '-'&#13;
        };&#13;
    }&#13;
&#13;
    function onEscClick(element) {&#13;
        if (escClicked) {&#13;
            $(element).val("");&#13;
        } else {&#13;
            presenter.disable();&#13;
            escClicked = true;&#13;
        }&#13;
        $(lastClickedElement).focus();&#13;
        $(lastClickedElement).click();&#13;
    }&#13;
&#13;
    presenter.run = function(view, model){&#13;
        runLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function(){&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (presenter.configuration.isError) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'open' : presenter.openCommand,&#13;
            'disable' : presenter.disable,&#13;
            'enable' : presenter.enable,&#13;
            'showCloseButton' : presenter.showCloseButton&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.showCloseButton = function () {&#13;
        presenter.isShowCloseButton = true;&#13;
    };&#13;
&#13;
    presenter.disable = function (){&#13;
        asyncFunctionDecorator(presenter.disableFunc.bind(this));&#13;
    };&#13;
&#13;
    presenter.disableFunc = function () {&#13;
        presenter.sendEvent("disable");&#13;
        if (presenter.configuration.openOnFocus) {&#13;
            keyboardIsVisible = false;&#13;
        }&#13;
&#13;
        presenter.configuration.$inputs.each(function (index, element) {&#13;
            try {&#13;
                $(element).data('keyboard').destroy();&#13;
            } catch(err){}&#13;
        });&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
&#13;
        presenter.configuration.$inputs.on('focusout', focusoutCallBack);&#13;
        presenter.configuration.$inputs.removeClass('ui-keyboard-input ui-keyboard-input-current');&#13;
        presenter.configuration.$inputs.removeAttr("readonly");&#13;
    };&#13;
&#13;
    presenter.enable = function () {&#13;
        asyncFunctionDecorator(presenter.enableFunc.bind(this));&#13;
    };&#13;
&#13;
    presenter.enableFunc = function () {&#13;
        presenter.sendEvent("enable");&#13;
        keyboardIsVisible = true;&#13;
        $(presenter.configuration.workWithViews).find('input').off('focusout', focusoutCallBack);&#13;
    };&#13;
&#13;
    presenter.open = function (moduleId, index) {&#13;
        asyncFunctionDecorator(presenter.openFunc.bind(this, moduleId, index));&#13;
    };&#13;
&#13;
    presenter.openFunc = function(moduleId, index) {&#13;
        var module = presenter.playerController.getModule(moduleId);&#13;
        try {&#13;
            var input = $(module.getView()).find('input:enabled').get(parseInt(index, 10) - 1);&#13;
            presenter.createEKeyboard(input, presenter.display);&#13;
            $(input).data('keyboard').reveal();&#13;
        } catch (e) {&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.openCommand = function(moduleId, index) {&#13;
        if ($.isArray(moduleId)) {&#13;
            presenter.open(moduleId[0], moduleId[1]);&#13;
        } else {&#13;
            presenter.open(moduleId, index);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.sendEvent = function (status) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': '',&#13;
            'value': status&#13;
        });&#13;
    };&#13;
&#13;
&#13;
&#13;
&#13;
    presenter.destroy = function destroy_addon_eKeyboard_function () {&#13;
        if (presenter.isPreview || !presenter.configuration) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.$inputs.off('focusout', focusoutCallBack);&#13;
&#13;
        presenter.configuration.$inputs.each(function (index, element){&#13;
            try {&#13;
                $(element).data('keyboard').destroy();&#13;
                $(element).off('focusout change paste keyup forceClick focus mousedown');&#13;
            } catch(err){}&#13;
        });&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        $(presenter.keyboardWrapper).remove();&#13;
        $(openButtonElement).remove();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function(){&#13;
    };&#13;
&#13;
    presenter.reset = function(){&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            "isClosed": keyboardIsVisible,&#13;
            "isShowCloseButton": presenter.isShowCloseButton&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var parsedState = JSON.parse(state);&#13;
        keyboardIsVisible = parsedState.isClosed;&#13;
&#13;
        if(parsedState.isShowCloseButton != undefined) {&#13;
            presenter.isShowCloseButton = parsedState.isShowCloseButton;&#13;
        }&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>