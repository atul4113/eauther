<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Coloring" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Image" name="Image" nameLabel="Coloring_property_image" type="image"/>
        <property displayName="Areas" name="Areas" nameLabel="Coloring_property_areas" type="text"/>
        <property displayName="Default Filling Color" name="DefaultFillingColor" nameLabel="Coloring_property_default_filling_color" type="string"/>
        <property displayName="Tolerance" name="Tolerance" nameLabel="Coloring_property_tolerance" type="string"/>
        <property displayName="Is Not Activity" name="isNotActivity" nameLabel="Coloring_property_is_not_activity" type="boolean"/>
        <property displayName="Is Disabled" name="isDisabled" nameLabel="Coloring_property_is_disabled" type="boolean"/>
        <property displayName="Disable fill on click" name="disableFill" nameLabel="Coloring_property_disable_fill" type="boolean"/>
        <property displayName="Color correct" name="colorCorrect" nameLabel="Coloring_property_color_correct" type="boolean"/>
    </model>
<css>.coloring-wrapper .coloring-container canvas {&#13;
    display: table;&#13;
    margin: auto;&#13;
}&#13;
&#13;
.coloring-wrapper {&#13;
    display: table;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    overflow: hidden;&#13;
    outline: none;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container {&#13;
    display: table-cell;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container {&#13;
    border: 1px solid #111111;&#13;
    border-radius: 50%;&#13;
    font-size: 10px;&#13;
    height: 8px;&#13;
    line-height: 6px;&#13;
    padding: 2px;&#13;
    position: absolute;&#13;
    width: 8px;&#13;
    font-weight: bold;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.wrong {&#13;
    background-color: #ff5599;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.correct {&#13;
    background-color: #55ff99;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.correct:after {&#13;
    content: 'v';&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.wrong:after {&#13;
    content: 'x';&#13;
}&#13;
</css><view>&lt;div class="coloring-wrapper"&gt;&#13;
    &lt;div class="coloring-container"&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="coloring-wrapper"&gt;&#13;
    &lt;div class="coloring-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonColoring_create(){&#13;
    /*&#13;
        KNOWN ISSUES:&#13;
            Areas - property validation - backward compatibility:&#13;
                Co-ordinates X &amp; Y:&#13;
                    Due to invalid validation, those values can be negative numbers or non-numbers strings. The addon behavior is to&#13;
                    display image, pass the validation and just do nothing. Browser probably will throw a small stack trace with function's&#13;
                    referring to getImageData on canvas. You shouldn't broke this invalid validation due to backward compatibility&#13;
                Transparent color:&#13;
                    It's have been added with validation : only numbers between range 0-255, without inproper strings&#13;
&#13;
            Default Filling Color - backward compatibility:&#13;
                Empty string:&#13;
                    Default color is [255, 100, 100, 255], when provided string is just empty one.&#13;
&#13;
    * */&#13;
&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.playerController = null;&#13;
    presenter.eventBus = null;&#13;
    presenter.lastEvent = null;&#13;
    presenter.imageHasBeenLoaded = false;&#13;
&#13;
    presenter.AREA_TYPE = {&#13;
        NORMAL: 0,&#13;
        TRANSPARENT: 1,&#13;
        USER_AREA: 2&#13;
    };&#13;
&#13;
    function areaObject(x, y, type) {&#13;
        this.x = x;&#13;
        this.y = y;&#13;
        this.type = type;&#13;
        this.defaultColor;&#13;
        this.pixelPosition;&#13;
        this.colorToFill = [];&#13;
&#13;
        this.getColor = function () {&#13;
            return presenter.getColorAtPoint(this.x, this.y);&#13;
        };&#13;
&#13;
        this.setPixelPosition = function () {&#13;
            this.pixelPosition = ((this.x + this.y * presenter.canvasWidth) * 4);&#13;
        };&#13;
    }&#13;
&#13;
    presenter.createPreview = function(view, model){&#13;
        runLogic(view, model, true);&#13;
    };&#13;
&#13;
    function setColorsThatCanBeFilled() {&#13;
        var configuration = presenter.configuration;&#13;
        configuration.colorsThatCanBeFilled = [];&#13;
        $.each(configuration.areas, function() {&#13;
            var color = presenter.getColorAtPoint(this.x, this.y);&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(color)) {&#13;
                configuration.colorsThatCanBeFilled.push(color);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
&#13;
        presenter.runEndedDeferred = new $.Deferred();&#13;
        presenter.runEnded = presenter.runEndedDeferred.promise();&#13;
&#13;
        presenter.eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        var score;&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(score)) {&#13;
            score = "";&#13;
        } else {&#13;
            score = score ? 1 : 0;&#13;
        }&#13;
&#13;
        return {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': item.join(';'),&#13;
            'value': value.toString(),&#13;
            'score': score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.sendEvent = function(item, value, score) {&#13;
        if (!presenter.isShowAnswersActive &amp;&amp; !presenter.setShowErrorsModeActive) {&#13;
            var eventData = presenter.createEventData(item, value, score);&#13;
            presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
&#13;
            if (presenter.isAllOK()) sendAllOKEvent();&#13;
        }&#13;
    };&#13;
&#13;
    function sendAllOKEvent() {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    function setAreasDefaultColors() {&#13;
        var configuration = presenter.configuration;&#13;
        $.each(configuration.areas, function() {&#13;
            this.defaultColor = presenter.getColorAtPoint(this.x, this.y);&#13;
        });&#13;
    }&#13;
&#13;
    function setAreasPixelPosition() {&#13;
        var configuration = presenter.configuration;&#13;
        $.each(configuration.areas, function() {&#13;
            this.pixelPosition = (this.x + this.y * presenter.canvasWidth) * 4;&#13;
        });&#13;
    }&#13;
&#13;
    function getClickedArea(clickObject) {&#13;
        var configuration = presenter.configuration;&#13;
        var clickedArea = new areaObject(clickObject.x, clickObject.y, presenter.AREA_TYPE.USER_AREA);&#13;
        clickedArea.setPixelPosition();&#13;
        clickedArea.colorToFill = [255, 255, 255, 255];&#13;
&#13;
        for(var i = 0; i &lt; configuration.areas.length; i++) {&#13;
            var area = configuration.areas[i];&#13;
&#13;
            if(isAreaColored(area)) {&#13;
                presenter.allColoredPixels = [];&#13;
                return area;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.userAreas == undefined) {&#13;
            presenter.configuration.userAreas = [];&#13;
        }&#13;
&#13;
        if (!isUserAreaExists()) {&#13;
            presenter.configuration.userAreas.push(clickedArea);&#13;
        }&#13;
&#13;
        presenter.allColoredPixels = [];&#13;
        return clickedArea;&#13;
    }&#13;
&#13;
    function isUserAreaExists() {&#13;
        var userAreas = presenter.configuration.userAreas;&#13;
        for(var i = 0; i &lt; userAreas.length; i++) {&#13;
            if(isAreaColored(userAreas[i])) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function isAreaColored(area) {&#13;
        return (presenter.allColoredPixels.indexOf(area.pixelPosition) != -1);&#13;
    }&#13;
&#13;
    presenter.clearArea = function (x, y, isRemovingWrongColor) {&#13;
        presenter.fillArea(x, y, '255 255 255 255', isRemovingWrongColor);&#13;
    };&#13;
&#13;
    presenter.fillArea = function (x, y, color, isRemovingWrongColor) {&#13;
        presenter.isColored = true;&#13;
&#13;
        presenter.click = {&#13;
            x: parseInt(x, 10),&#13;
            y: parseInt(y, 10)&#13;
        };&#13;
&#13;
        presenter.click.color = presenter.getColorAtPoint(presenter.click.x, presenter.click.y);&#13;
&#13;
        if (color == undefined) {&#13;
            presenter.fillColor = presenter.configuration.currentFillingColor;&#13;
        } else {&#13;
            var validatedDefaultFillingColor = presenter.validateColor(color);&#13;
            if (validatedDefaultFillingColor.isError) {&#13;
                DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, validatedDefaultFillingColor.errorCode);&#13;
                return;&#13;
            }&#13;
            presenter.fillColor = validatedDefaultFillingColor.value;&#13;
        }&#13;
&#13;
        if ( presenter.isAlreadyInColorsThatCanBeFilled(presenter.click.color) || isRemovingWrongColor) {&#13;
            if (!presenter.isShowAnswersActive &amp;&amp; !presenter.setShowErrorsModeActive) {&#13;
                presenter.floodFill(&#13;
                    presenter.click,&#13;
                    presenter.fillColor,&#13;
                    presenter.configuration.tolerance&#13;
                );&#13;
            }&#13;
&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(presenter.fillColor)) {&#13;
                presenter.configuration.colorsThatCanBeFilled.push(presenter.fillColor)&#13;
            }&#13;
        }&#13;
&#13;
        presenter.allColoredPixels = [];&#13;
    };&#13;
&#13;
    presenter.checkIfColoredCorrectly = function () {&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            var area = this;&#13;
&#13;
            if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                return true; // continue&#13;
            }&#13;
&#13;
            if (!isCorrect(area)) {&#13;
                    var r = area.colorToFill[0],&#13;
                        g = area.colorToFill[1],&#13;
                        b = area.colorToFill[2],&#13;
                        a = area.colorToFill[3],&#13;
                        color = r + " " + g + " " + b + " " + a;&#13;
                if(r != -1){&#13;
                    presenter.fillArea(area.x, area.y, color, false);&#13;
                }else{&#13;
                    presenter.fillArea(area.x, area.y, '0 0 0 0', false);&#13;
                }&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.clickLogic = function(e, isTouch) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
&#13;
        presenter.isColored = true;&#13;
&#13;
        presenter.click = getMousePositionOnCanvas(e, isTouch);&#13;
&#13;
        presenter.click.color = presenter.getColorAtPoint(presenter.click.x, presenter.click.y);&#13;
&#13;
        if (presenter.configuration.disableFill) {&#13;
            presenter.sendEvent([presenter.click.x, presenter.click.y], '', '');&#13;
&#13;
            return false;&#13;
        }&#13;
&#13;
        if ( presenter.isAlreadyInColorsThatCanBeFilled(presenter.click.color) ) {&#13;
&#13;
            if (!presenter.isShowAnswersActive &amp;&amp; !presenter.setShowErrorsModeActive) {&#13;
                presenter.floodFill(&#13;
                    presenter.click,&#13;
                    presenter.configuration.currentFillingColor,&#13;
                    presenter.configuration.tolerance&#13;
                );&#13;
            }&#13;
&#13;
            if(!presenter.configuration.colorCorrect){&#13;
                presenter.userInteractionSendingEvent(getClickedArea(presenter.click));&#13;
            }&#13;
&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(presenter.configuration.currentFillingColor)) {&#13;
                presenter.configuration.colorsThatCanBeFilled.push(presenter.configuration.currentFillingColor)&#13;
            }&#13;
        }&#13;
        if(presenter.configuration.colorCorrect){&#13;
            presenter.checkIfColoredCorrectly();&#13;
            presenter.sendEvent([presenter.click.x, presenter.click.y], presenter.configuration.isErase ? 0 : 1, 1);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.userInteractionSendingEvent = function (clickedArea) {&#13;
        if (clickedArea.type == presenter.AREA_TYPE.USER_AREA) {&#13;
            presenter.sendEvent([clickedArea.x, clickedArea.y], presenter.configuration.isErase ? 0 : 1, "");&#13;
        } else {&#13;
            presenter.sendEvent([clickedArea.x, clickedArea.y], presenter.configuration.isErase ? 0 : 1, isCorrect(clickedArea) ? 1 : 0);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.recolorImage = function () {&#13;
        var imageData = presenter.ctx.getImageData(0, 0,presenter.canvasWidth, presenter.canvasHeight);&#13;
&#13;
        for (var i=0; i&lt;imageData.data.length; i+=4) {&#13;
            if (imageData.data[i]==0 &amp;&amp;&#13;
                imageData.data[i+1]==0 &amp;&amp;&#13;
                imageData.data[i+2]==0 &amp;&amp;&#13;
                imageData.data[i+3]==255&#13;
                ){&#13;
                imageData.data[i]=55;&#13;
                imageData.data[i+1]=55;&#13;
                imageData.data[i+2]=55;&#13;
                imageData.data[i+3]=255;&#13;
            }&#13;
        }&#13;
&#13;
        presenter.ctx.putImageData(imageData,0,0);&#13;
    };&#13;
&#13;
    function runLogic(view, model, isPreview) {&#13;
        presenter.configuration = presenter.validateModel(model, isPreview);&#13;
        presenter.allColoredPixels = [];&#13;
&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage($(view), presenter.errorCodes, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view = $(view);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        var imageElement = $('&lt;img&gt;');&#13;
&#13;
        if(presenter.configuration.imageFile.indexOf("/file/serve") == 0){&#13;
            presenter.configuration.imageFile = presenter.configuration.imageFile + "?no_gcs=true";&#13;
        }&#13;
&#13;
        imageElement.attr('src', presenter.configuration.imageFile);&#13;
&#13;
        var canvasElement = $('&lt;canvas&gt;&lt;/canvas&gt;');&#13;
        presenter.ctx = canvasElement[0].getContext('2d');&#13;
&#13;
        imageElement.load(function() {&#13;
            canvasElement.attr('width', imageElement[0].width);&#13;
            canvasElement.attr('height', imageElement[0].height);&#13;
            presenter.canvasWidth = imageElement[0].width;&#13;
            presenter.canvasHeight = imageElement[0].height;&#13;
            presenter.canvas = canvasElement[0];&#13;
&#13;
            presenter.ctx.drawImage(imageElement[0], 0, 0);&#13;
            presenter.imageHasBeenLoaded = true;&#13;
&#13;
            presenter.imageData = presenter.ctx.getImageData(0, 0, imageElement[0].width, imageElement[0].height);&#13;
&#13;
            presenter.image = imageElement;&#13;
&#13;
            var coloringContainer = presenter.$view.find('.coloring-container');&#13;
&#13;
            coloringContainer.append(canvasElement);&#13;
&#13;
            presenter.canvasOffset = canvasElement.offset();&#13;
&#13;
            setColorsThatCanBeFilled();&#13;
            setAreasDefaultColors();&#13;
            setAreasPixelPosition();&#13;
&#13;
            if (isPreview) {&#13;
                var coordinatesContainer = $('&lt;div&gt;&lt;/div&gt;'),&#13;
                    xContainer = $('&lt;div&gt;x: &lt;span class="value"&gt;&lt;/span&gt;&lt;/div&gt;'),&#13;
                    yContainer = $('&lt;div&gt;y: &lt;span class="value"&gt;&lt;/span&gt;&lt;/div&gt;'),&#13;
                    coloringWrapper = presenter.$view.find('.coloring-wrapper');&#13;
&#13;
                coordinatesContainer.css({&#13;
                    'width' : 60,&#13;
                    'height' : 25,&#13;
                    'border' : '1px solid #696969',&#13;
                    'borderRadius' : '3px',&#13;
                    'position' : 'absolute',&#13;
                    'top' : 5,&#13;
                    'left' : 5,&#13;
                    'fontSize' : '9px',&#13;
                    'padding': '5px',&#13;
                    'lineHeight' : '12px'&#13;
                });&#13;
&#13;
                coordinatesContainer&#13;
                    .append(xContainer)&#13;
                    .append(yContainer);&#13;
&#13;
                coloringWrapper.append(coordinatesContainer);&#13;
                coloringWrapper.css({&#13;
                    'position' : 'relative',&#13;
                    'minHeight' : presenter.canvasHeight,&#13;
                    'minWidth' : presenter.canvasWidth&#13;
                });&#13;
&#13;
                var moduleSelector = $('.moduleSelector[data-id="'+presenter.configuration.addonID+'"]');&#13;
&#13;
                moduleSelector.on('mousemove', function(e) {&#13;
                    xContainer.find('.value').html(getMousePositionOnCanvas(e).x);&#13;
                    yContainer.find('.value').html(getMousePositionOnCanvas(e).y);&#13;
                });&#13;
&#13;
                canvasElement.on('mousemove', function(e) {&#13;
                    xContainer.find('.value').html(getMousePositionOnCanvas(e).x);&#13;
                    yContainer.find('.value').html(getMousePositionOnCanvas(e).y);&#13;
                });&#13;
            } else if (!presenter.configuration.isDisabled) {&#13;
                canvasElement.on('click', function(e) {&#13;
                    presenter.clickLogic(e);&#13;
                });&#13;
&#13;
                canvasElement.on('touchstart', function (e){&#13;
                    presenter.lastEvent = e;&#13;
                });&#13;
&#13;
                canvasElement.on('touchend', function (e){&#13;
                    if ( presenter.lastEvent.type != e.type ) {&#13;
                        presenter.clickLogic(e, true);&#13;
                    }&#13;
                });&#13;
&#13;
                presenter.recolorImage();&#13;
                presenter.runEndedDeferred.resolve();&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.run = function(view, model){&#13;
        runLogic(view, model, false);&#13;
&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.isAlreadyInColorsThatCanBeFilled = function(color) {&#13;
        for (var i = 0; i &lt; presenter.configuration.colorsThatCanBeFilled.length; i++) {&#13;
            if (presenter.compareArrays(color, presenter.configuration.colorsThatCanBeFilled[i])) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.compareArrays = function(array1, array2) {&#13;
        // if the other array is a falsy value, return&#13;
        if (!array2)&#13;
            return false;&#13;
&#13;
        // compare lengths - can save a lot of time&#13;
        if (array1.length != array2.length)&#13;
            return false;&#13;
&#13;
        for (var i = 0, l=array1.length; i &lt; l; i++) {&#13;
            if (array1[i] != array2[i] &amp;&amp; (array1[i]+1) != array2[i] &amp;&amp; (array1[i]-1) != array2[i]) {&#13;
                //Due to the lossy nature of converting to and from premultiplied alpha color values,&#13;
                // pixels that have just been set using putImageData() might be returned to an equivalent getImageData() as different values. http://www.w3.org/TR/2dcontext/#dom-context-2d-getimagedata&#13;
                // Warning - two different object instances will never be equal: {x:20} != {x:20}&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.getColorAtPoint = function(x, y) {&#13;
        var data = presenter.ctx.getImageData(x, y, 1, 1).data,&#13;
            color = [];&#13;
        for (var i = 0; i &lt; data.length; i++) {&#13;
            color.push(data[i]);&#13;
        }&#13;
        return color;&#13;
    };&#13;
&#13;
    function fixTouch (touch) {&#13;
        var winPageX = window.pageXOffset,&#13;
            winPageY = window.pageYOffset,&#13;
            x = touch.clientX,&#13;
            y = touch.clientY;&#13;
&#13;
        if (touch.pageY === 0 &amp;&amp; Math.floor(y) &gt; Math.floor(touch.pageY) ||&#13;
            touch.pageX === 0 &amp;&amp; Math.floor(x) &gt; Math.floor(touch.pageX)) {&#13;
            // iOS4 clientX/clientY have the value that should have been&#13;
            // in pageX/pageY. While pageX/page/ have the value 0&#13;
            x = x - winPageX;&#13;
            y = y - winPageY;&#13;
        } else if (y &lt; (touch.pageY - winPageY) || x &lt; (touch.pageX - winPageX) ) {&#13;
            // Some Android browsers have totally bogus values for clientX/Y&#13;
            // when scrolling/zooming a page. Detectable since clientX/clientY&#13;
            // should never be smaller than pageX/pageY minus page scroll&#13;
            x = touch.pageX - winPageX;&#13;
            y = touch.pageY - winPageY;&#13;
        }&#13;
&#13;
        return {&#13;
            x: x,&#13;
            y: y&#13;
        };&#13;
    }&#13;
&#13;
    function getMousePositionOnCanvas(e, isTouch) {&#13;
        var rect = presenter.canvas.getBoundingClientRect(),&#13;
            client = {&#13;
                x: e.clientX,&#13;
                y: e.clientY&#13;
            };&#13;
&#13;
        if (isTouch) {&#13;
            client = fixTouch(event.touches[0] || event.changedTouches[0]);&#13;
        }&#13;
&#13;
        return {&#13;
            x: parseInt(client.x - rect.left, 10),&#13;
            y: parseInt(client.y - rect.top, 10)&#13;
        };&#13;
    }&#13;
&#13;
    presenter.errorCodes = {&#13;
        'E01': 'Wrong color notation. Must be in "r g b a" format. See documentation for more details.',&#13;
        'E02': 'All color values must be between 0 - 255.',&#13;
        'E03': 'Areas are configured wrong. It should be in "x; y; color" format. See documentation for more details.',&#13;
        'E04': 'Areas x &amp; y values have to be smaller than Width and Height properties.',&#13;
        'A01': "Areas x &amp; y values have to be integer values between 0 - 255."&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model, isPreview) {&#13;
        var validatedAreas = {&#13;
            items: []&#13;
        };&#13;
&#13;
        if (model['Areas'].toString().length &gt; 0) {&#13;
            validatedAreas = presenter.validateAreas(model['Areas'], isPreview, model['Width'], model['Height']);&#13;
            if (validatedAreas.isError) {&#13;
                return { isError: true, errorCode: validatedAreas.errorCode};&#13;
            }&#13;
        }&#13;
&#13;
        var validatedTolerance = {};&#13;
        if (model['Tolerance'].toString().length === 0) {&#13;
            validatedTolerance.value = 50;&#13;
        } else {&#13;
            validatedTolerance = ModelValidationUtils.validateIntegerInRange(model['Tolerance'], 100, 0);&#13;
            if (validatedTolerance.isError) {&#13;
                return { isError: true, errorCode: validatedTolerance.errorCode};&#13;
            }&#13;
        }&#13;
&#13;
        var validatedDefaultFillingColor = {};&#13;
        if (model['DefaultFillingColor'].toString().length === 0) {&#13;
&#13;
            validatedDefaultFillingColor.value = [255, 100, 100, 255];&#13;
&#13;
        } else {&#13;
&#13;
            validatedDefaultFillingColor = presenter.validateColor(model['DefaultFillingColor']);&#13;
            if (validatedDefaultFillingColor.isError) {&#13;
                return { isError: true, errorCode: validatedDefaultFillingColor.errorCode};&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        var validatedIsVisible = ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            validatedIsDisabled = ModelValidationUtils.validateBoolean(model['isDisabled']);&#13;
&#13;
        return {&#13;
            'isValid': true,&#13;
            'isError': false,&#13;
            'addonID' : model['ID'],&#13;
&#13;
            'imageFile': model.Image,&#13;
            'areas' : validatedAreas.items,&#13;
            'tolerance' : validatedTolerance.value,&#13;
            'currentFillingColor' : validatedDefaultFillingColor.value,&#13;
            'defaultFillingColor' : validatedDefaultFillingColor.value,&#13;
            'isErase' : false,&#13;
            'isVisible' : validatedIsVisible,&#13;
            'isVisibleByDefault' : validatedIsVisible,&#13;
            'isDisabled' : validatedIsDisabled,&#13;
            'isDisabledByDefault' : validatedIsDisabled,&#13;
            'isActivity' : !(ModelValidationUtils.validateBoolean(model['isNotActivity'])),&#13;
            'lastUsedColor' : validatedDefaultFillingColor.value,&#13;
            'disableFill' : ModelValidationUtils.validateBoolean(model['disableFill']),&#13;
            'colorCorrect' : ModelValidationUtils.validateBoolean(model.colorCorrect)&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getErrorObject = function (errorCode) {&#13;
        return {isValid: false, isError: true, errorCode: errorCode};&#13;
    };&#13;
&#13;
    presenter.parseTransparentArea = function (splitedAreaArray) {&#13;
        var area = {&#13;
            x: parseInt(Number(splitedAreaArray[0])),&#13;
            y: parseInt(Number(splitedAreaArray[1])),&#13;
            type: presenter.AREA_TYPE.TRANSPARENT,&#13;
            colorToFill: [-1, -1, -1, -1]&#13;
        };&#13;
&#13;
        if (isNaN(area.x) || isNaN(area.y)) {&#13;
            return presenter.getErrorObject("A01");&#13;
        }&#13;
&#13;
        if (area.x &lt; 0 || area.y &lt; 0) {&#13;
            return presenter.getErrorObject("A01");&#13;
        }&#13;
&#13;
        area.isError = false;&#13;
&#13;
        return area;&#13;
    };&#13;
&#13;
    presenter.isTransparent = function (value) {&#13;
        if (value.length === 3) {&#13;
            return value[2] === "transparent";&#13;
        }&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.validateAreas = function(areasText, isPreview, modelWidth, modelHeight) {&#13;
        modelWidth = parseInt(modelWidth, 10);&#13;
        modelHeight = parseInt(modelHeight, 10);&#13;
        var areas = Helpers.splitLines(areasText).map(function (element) {&#13;
           return element.split(';');&#13;
        }).map(function (element) {&#13;
&#13;
            if (element.length === 3) {&#13;
                var trimmedArray = element.map(function (value) {return value.trim();});&#13;
&#13;
                if (presenter.isTransparent(trimmedArray)) {&#13;
                    return presenter.parseTransparentArea(trimmedArray);&#13;
                } else {&#13;
                    var area = {&#13;
                        x: parseInt(trimmedArray[0], 10),&#13;
                        y: parseInt(trimmedArray[1], 10),&#13;
                        type: presenter.AREA_TYPE.NORMAL&#13;
                    };&#13;
&#13;
                    if(isPreview &amp;&amp; (area.x&gt;=modelWidth || area.y&gt;=modelHeight)) {&#13;
                        return {isValid: false, isError: true, errorCode: 'E04'};&#13;
                    }&#13;
&#13;
                    var validatedColor = presenter.validateColor(trimmedArray[2]);&#13;
                    if(!validatedColor.isError) {&#13;
                      area.colorToFill = validatedColor.value;&#13;
                      area.isError = false;&#13;
                      return area;&#13;
                    }&#13;
                }&#13;
&#13;
                return {isValid: false, isError: true, errorCode: validatedColor.errorCode};&#13;
            }&#13;
&#13;
            return {isValid: false, isError: true, errorCode: 'E03'};&#13;
        });&#13;
&#13;
        var errors = areas.filter(function (element) {if (element.isError) return element;});&#13;
        if (errors.length &gt; 0) {&#13;
            return errors[0];&#13;
        }&#13;
&#13;
        return {isValid: true, isError: false, items: areas};&#13;
    };&#13;
&#13;
    presenter.validateColor = function(spaceSeparatedColor) {&#13;
        var splitted = spaceSeparatedColor.split(' '),&#13;
            validatedColors = [];&#13;
&#13;
        if (splitted.length &lt; 4) {&#13;
            return {isError: true, errorCode: 'E01'};&#13;
        }&#13;
&#13;
        var areAllValuesInRange = true;&#13;
        $.each(splitted, function() {&#13;
&#13;
            var validated = ModelValidationUtils.validateIntegerInRange(this, 255, 0);&#13;
            if (!validated.isValid) {&#13;
                areAllValuesInRange = false;&#13;
                return;&#13;
            }&#13;
            validatedColors.push(validated.value);&#13;
        });&#13;
&#13;
        if (!areAllValuesInRange) {&#13;
            return { isError: true, errorCode: 'E02'};&#13;
        }&#13;
&#13;
        return { value: validatedColors, isError: false};&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.disable = function() {&#13;
        presenter.configuration.isDisabled = true;&#13;
        $(presenter.canvas).off('click touchstart touchend');&#13;
        $(presenter.canvas).on('click touchstart touchend', function(e) {&#13;
            e.stopPropagation();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.enable = function() {&#13;
        presenter.configuration.isDisabled = false;&#13;
        $(presenter.canvas).off('click');&#13;
        $(presenter.canvas).on('click', function(e){&#13;
            presenter.clickLogic(e);&#13;
        });&#13;
&#13;
        $(presenter.canvas).off('touchstart');&#13;
        $(presenter.canvas).on('touchstart', function (e){&#13;
            e.stopPropagation();&#13;
            e.preventDefault();&#13;
&#13;
            presenter.lastEvent = e;&#13;
        });&#13;
&#13;
        $(presenter.canvas).off('touchend');&#13;
        $(presenter.canvas).on('touchend', function (e){&#13;
            e.stopPropagation();&#13;
            e.preventDefault();&#13;
&#13;
            if ( presenter.lastEvent.type != e.type ) {&#13;
                presenter.clickLogic(e, true);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getView = function() {&#13;
        return presenter.$view;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function() {&#13;
        var actualScore = presenter.getScore();&#13;
&#13;
        if (presenter.configuration.transparentAreaError) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return actualScore === presenter.getMaxScore();&#13;
    };&#13;
&#13;
    presenter.isAttempted = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return presenter.isColored || false;&#13;
    };&#13;
&#13;
    presenter.getColor = function(x, y) {&#13;
        if (x === undefined || y === undefined) return;&#13;
&#13;
        return presenter.getColorAtPoint(x, y).join(' ');&#13;
    };&#13;
&#13;
    presenter.removeWrongColors = function () {&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            var area = this;&#13;
&#13;
            if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                return true; // continue&#13;
            }&#13;
&#13;
            if (!isCorrect(area)) {&#13;
                presenter.clearArea(area.x, area.y, true);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'disable' : presenter.disable,&#13;
            'enable' : presenter.enable,&#13;
            'isAllOK' : presenter.isAllOK,&#13;
            'getView' : presenter.getView,&#13;
            'setColor' : presenter.setColorCommand,&#13;
            'setEraserOn' : presenter.setEraserOn,&#13;
            'isAttempted' : presenter.isAttempted,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'fillArea' : presenter.fillAreaCommand,&#13;
            'clearArea' : presenter.clearAreaCommand,&#13;
            'getColor' : presenter.getColor,&#13;
            'removeWrongColors': presenter.removeWrongColors&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setEraserOn = function() {&#13;
        presenter.configuration.isErase = true;&#13;
        presenter.configuration.lastUsedColor = presenter.configuration.currentFillingColor;&#13;
        presenter.configuration.currentFillingColor = [255, 255, 255, 255];&#13;
    };&#13;
&#13;
    presenter.clearAreaCommand = function (coordinates){&#13;
        presenter.clearArea(coordinates[0], coordinates[1], false);&#13;
    };&#13;
&#13;
    presenter.fillAreaCommand = function(coordinatesAndColor) {&#13;
        presenter.fillArea(coordinatesAndColor[0], coordinatesAndColor[1], coordinatesAndColor[2], false);&#13;
    };&#13;
&#13;
    presenter.setColorCommand = function(color) {&#13;
        presenter.setColor(color[0]);&#13;
    };&#13;
&#13;
    presenter.setColor = function(color) {&#13;
        var validatedDefaultFillingColor = presenter.validateColor(color);&#13;
        if (validatedDefaultFillingColor.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, validatedDefaultFillingColor.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.currentFillingColor = validatedDefaultFillingColor.value;&#13;
        presenter.configuration.isErase = false;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity) {&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                var area = this;&#13;
&#13;
                if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                    return true; // continue&#13;
                }&#13;
&#13;
                if (isCorrect(area)) {&#13;
                    displayIcon(area, false);&#13;
                } else {&#13;
                    displayIcon(area, true);&#13;
                }&#13;
            });&#13;
        }&#13;
        presenter.setShowErrorsModeActive = true;&#13;
    };&#13;
&#13;
    function displayIcon(area, isWrong) {&#13;
        var iconContainer = $('&lt;div class="icon-container"&gt;&lt;/div&gt;'),&#13;
            container = presenter.$view.find('.coloring-container'),&#13;
            containerWidth = container.width(),&#13;
            canvasWidth = $(presenter.canvas).width(),&#13;
            leftDistance = (containerWidth-canvasWidth)/ 2,&#13;
            position = $(presenter.canvas).position(),&#13;
            top = area.y + position.top - 5, // -5 because it's half of the icon container width and height&#13;
            left = area.x + leftDistance - 5;&#13;
&#13;
        iconContainer.css({&#13;
            top: top + 'px',&#13;
            left: left + 'px'&#13;
        });&#13;
&#13;
        iconContainer.addClass(isWrong ? 'wrong' : 'correct');&#13;
&#13;
        container.append(iconContainer);&#13;
    }&#13;
&#13;
    presenter.setWorkMode = function(){&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.setShowErrorsModeActive = false;&#13;
    };&#13;
&#13;
    presenter.clearCanvas = function() {&#13;
        presenter.ctx.clearRect(0, 0, presenter.canvasWidth, presenter.canvasHeight);&#13;
        presenter.ctx.drawImage(presenter.image[0], 0, 0);&#13;
    };&#13;
&#13;
    presenter.reset = function(){&#13;
        presenter.clearCanvas();&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.isColored = false;&#13;
        presenter.isShowAnswersActive = false;&#13;
        presenter.setShowErrorsModeActive = false;&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
&#13;
        presenter.configuration.isDisabled = presenter.configuration.isDisabledByDefault;&#13;
        presenter.configuration.isDisabledByDefault ? presenter.disable() : presenter.enable();&#13;
&#13;
        if (presenter.configuration.isErase) {&#13;
            presenter.configuration.currentFillingColor = presenter.configuration.lastUsedColor;&#13;
            presenter.configuration.isErase = false;&#13;
        } else {&#13;
            presenter.configuration.currentFillingColor = presenter.configuration.defaultFillingColor;&#13;
        }&#13;
&#13;
        setColorsThatCanBeFilled();&#13;
        presenter.recolorImage();&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return presenter.currentErrorCount;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity &amp;&amp; presenter.imageHasBeenLoaded) {&#13;
            var errorsCount = 0;&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                var area = this;&#13;
&#13;
                if (!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                    return true; // continue&#13;
                }&#13;
&#13;
                if (!isCorrect(area)) {&#13;
                    errorsCount++;&#13;
                }&#13;
            });&#13;
            return errorsCount;&#13;
        } else if (presenter.configuration.isActivity &amp;&amp; presenter.savedErrorCount) {&#13;
            return 0;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    function isCorrect(area) {&#13;
        return presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.colorToFill);&#13;
    }&#13;
&#13;
    presenter.shouldBeTakenIntoConsideration = function(area) {&#13;
        return !presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.defaultColor);&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function(){&#13;
        if (presenter.configuration.isActivity) {&#13;
            var normalAreas = presenter.configuration.areas.filter(function (element) {&#13;
                   return (element.type == presenter.AREA_TYPE.NORMAL);&#13;
            });&#13;
&#13;
            return normalAreas.length;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getScoreForNormalArea = function (area) {&#13;
        if (!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
            return 0; // continue&#13;
        }&#13;
&#13;
        if (isCorrect(area)) {&#13;
            return 1;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScoreForTransparentArea = function (area) {&#13;
&#13;
        if(!presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.defaultColor)) {&#13;
            presenter.configuration.transparentAreaError = true;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return presenter.currentScore;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity &amp;&amp; presenter.imageHasBeenLoaded) {&#13;
            var scoreCount = 0;&#13;
            presenter.configuration.transparentAreaError = false;&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                switch(this.type) {&#13;
                    case presenter.AREA_TYPE.NORMAL:&#13;
                        scoreCount += presenter.getScoreForNormalArea(this);&#13;
                        break;&#13;
                    case presenter.AREA_TYPE.TRANSPARENT:&#13;
                        scoreCount += presenter.getScoreForTransparentArea(this);&#13;
                        break;&#13;
                }&#13;
            });&#13;
&#13;
            return scoreCount;&#13;
        } else if (presenter.configuration.isActivity &amp;&amp; presenter.savedScore) {&#13;
            return 0;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getState = function(){&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var filledAreas = [];&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            if (presenter.shouldBeTakenIntoConsideration(this)) {&#13;
                filledAreas.push({&#13;
                    area: this,&#13;
                    color: presenter.getColorAtPoint(this.x, this.y)&#13;
                });&#13;
            }&#13;
        });&#13;
&#13;
        var userAreas = [];&#13;
        if (presenter.configuration.userAreas != undefined) {&#13;
            userAreas = presenter.configuration.userAreas.map(function (elem) {&#13;
                return {&#13;
                    area: {x: elem.x, y: elem.y, type: elem.type, pixelPosition: elem.pixelPosition, colorToFill: elem.colorToFill},&#13;
                    color: elem.getColor()};&#13;
            });&#13;
        }&#13;
&#13;
&#13;
        var state = {&#13;
            filledAreas: filledAreas,&#13;
            currentFillingColor: presenter.configuration.currentFillingColor,&#13;
            isErase: presenter.configuration.isErase,&#13;
            colorsThatCanBeFilled: presenter.configuration.colorsThatCanBeFilled,&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            isDisabled: presenter.configuration.isDisabled,&#13;
            isColored: presenter.isColored,&#13;
            score: presenter.getScore(),&#13;
            errorCount: presenter.getErrorCount(),&#13;
            userAreas: userAreas&#13;
        };&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
    presenter.upgradeState = function(state) {&#13;
&#13;
        if (state.userAreas == undefined) {&#13;
            return presenter.upgradeUserAreas(state);&#13;
        }&#13;
&#13;
        return state;&#13;
    };&#13;
&#13;
    presenter.upgradeUserAreas = function(state) {&#13;
        var upgradedState = {};&#13;
        jQuery.extend(true, upgradedState, state); // Deep copy of model object&#13;
&#13;
        if(state.userAreas == undefined) {&#13;
            upgradedState["userAreas"] = [];&#13;
        }&#13;
&#13;
        return upgradedState;&#13;
    };&#13;
&#13;
    presenter.restoreUserAreasFromState = function (state) {&#13;
        presenter.configuration.userAreas = [];&#13;
&#13;
        $.each(state.userAreas, function() {&#13;
            var userArea = new areaObject(this.area.x, this.area.y, this.area.type);&#13;
            userArea.pixelPosition = this.area.pixelPosition;&#13;
            userArea.colorToFill = this.area.colorToFill;&#13;
&#13;
            presenter.configuration.userAreas.push(userArea);&#13;
        });&#13;
&#13;
    };&#13;
&#13;
    presenter.getAreasToFillFromSetState = function (state) {&#13;
        var filledAreasArray = state.filledAreas;&#13;
        filledAreasArray = filledAreasArray.concat(state.userAreas);&#13;
&#13;
        return filledAreasArray&#13;
    };&#13;
&#13;
    presenter.setCurrentFillingColorInSetState = function (state) {&#13;
        if (presenter.configuration.isErase) {&#13;
            presenter.configuration.currentFillingColor = [255, 255, 255, 255];&#13;
        } else {&#13;
            presenter.configuration.currentFillingColor = state.currentFillingColor;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setState = function(state){&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsed = JSON.parse(state);&#13;
        var upgradedState = presenter.upgradeState(parsed);&#13;
&#13;
        presenter.configuration.isErase = upgradedState.isErase;&#13;
        presenter.configuration.isVisible = upgradedState.isVisible;&#13;
        presenter.configuration.isDisabled = upgradedState.isDisabled;&#13;
        presenter.isColored = upgradedState.isColored;&#13;
        presenter.savedScore = upgradedState.score;&#13;
        presenter.savedErrorCount = upgradedState.errorCount;&#13;
&#13;
        presenter.setCurrentFillingColorInSetState(upgradedState);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
&#13;
        presenter.restoreUserAreasFromState(upgradedState);&#13;
&#13;
        var areasToFill = presenter.getAreasToFillFromSetState(upgradedState);&#13;
&#13;
        presenter.restoreColoringAtState(areasToFill, upgradedState)&#13;
    };&#13;
&#13;
    presenter.restoreColoringAtState = function (filledAreasArray, state) {&#13;
        presenter.runEnded.then(function() {&#13;
            presenter.configuration.colorsThatCanBeFilled = state.colorsThatCanBeFilled;&#13;
            $.each(filledAreasArray, presenter.restoreFilledArea);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.restoreFilledArea = function (_, areaToFillObject) {&#13;
        presenter.floodFill({&#13;
            x: areaToFillObject.area.x,&#13;
            y: areaToFillObject.area.y,&#13;
            color: [255, 255, 255, 255]&#13;
        },&#13;
&#13;
        areaToFillObject.color,&#13;
        presenter.configuration.tolerance);&#13;
        presenter.allColoredPixels = [];&#13;
    };&#13;
&#13;
    presenter.floodFill = function (position, fillColor, tolerance) {&#13;
        var img = presenter.ctx.getImageData(0, 0, presenter.canvasWidth, presenter.canvasHeight),&#13;
            surface = img.data,&#13;
            length = surface.length,&#13;
            queue = [],&#13;
            x = position.x,&#13;
            y = position.y,&#13;
            targetColor = position.color,&#13;
            startingPixel = (x + y * presenter.canvasWidth) * 4,&#13;
            east = startingPixel, west = startingPixel, rightBound, leftBound, leftEdge = presenter.canvasWidth * 4;&#13;
&#13;
        if(!pixelCompare(startingPixel, targetColor, fillColor, surface, length, tolerance).canFill) { return false; }&#13;
&#13;
        queue.push(startingPixel);&#13;
&#13;
        while(queue.length) {&#13;
            startingPixel = queue.pop();&#13;
&#13;
            if(pixelCompareAndSet(startingPixel, targetColor, fillColor, surface, length, tolerance)) {&#13;
                east = startingPixel;&#13;
                west = startingPixel;&#13;
                leftBound = parseInt(startingPixel / leftEdge) * leftEdge; //left bound&#13;
                rightBound = leftBound + leftEdge;	//right bound&#13;
                while(leftBound &lt; (west -= 4) &amp;&amp; pixelCompareAndSet(west, targetColor, fillColor, surface, length, tolerance)); //go left until edge hit&#13;
&#13;
                while(rightBound &gt; (east += 4) &amp;&amp; pixelCompareAndSet(east, targetColor, fillColor, surface, length, tolerance)); //go right until edge hit&#13;
&#13;
                for(var j = west; j &lt; east; j += 4) {&#13;
                    if(j - leftEdge &gt;= 0 		&amp;&amp; pixelCompare(j - leftEdge, targetColor, fillColor, surface, length, tolerance).canFill) queue.push(j - leftEdge);&#13;
                    if(j + leftEdge &lt; length	&amp;&amp; pixelCompare(j + leftEdge, targetColor, fillColor, surface, length, tolerance).canFill) queue.push(j + leftEdge);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.ctx.putImageData(img, 0, 0);&#13;
    };&#13;
&#13;
    function pixelCompare(i, targetColor, fillColor, surface, length, tolerance) {&#13;
        if (i &lt; 0 || i &gt;= length) { // out of bounds&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
        if (surface[i + 3] === 0) { //surface is invisible&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (targetColor[3] === fillColor[3] &amp;&amp; //target is same as fill&#13;
            targetColor[0] === fillColor[0] &amp;&amp;&#13;
            targetColor[1] === fillColor[1] &amp;&amp;&#13;
            targetColor[2] === fillColor[2]) {&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (fillColor[3] === surface[i+3] &amp;&amp; // surface matches fillColor&#13;
            fillColor[0] === surface[i]  &amp;&amp;&#13;
            fillColor[1] === surface[i+1] &amp;&amp;&#13;
            fillColor[2] === surface[i+2]) {&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        if (targetColor[3] === surface[i + 3] &amp;&amp; //target matches surface&#13;
            targetColor[0] === surface[i]  &amp;&amp;&#13;
            targetColor[1] === surface[i + 1] &amp;&amp;&#13;
            targetColor[2] === surface[i + 2]) {&#13;
&#13;
            return {&#13;
                canFill: true,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (Math.abs(targetColor[3] - surface[i + 3]) &lt;= (255 - tolerance) &amp;&amp; //target to surface within tolerance&#13;
            Math.abs(targetColor[0] - surface[i]) &lt;= tolerance &amp;&amp;&#13;
            Math.abs(targetColor[1] - surface[i + 1]) &lt;= tolerance &amp;&amp;&#13;
            Math.abs(targetColor[2] - surface[i + 2]) &lt;= tolerance) {&#13;
&#13;
            return {&#13;
                canFill: true,&#13;
                withinTolerance: true&#13;
            };&#13;
&#13;
        }&#13;
&#13;
        return {&#13;
            canFill: false,&#13;
            withinTolerance: false&#13;
        }; //no match&#13;
    }&#13;
&#13;
    function pixelCompareAndSet(i, targetColor, fillColor, surface, length, tolerance) {&#13;
        var compareResult = pixelCompare(i, targetColor, fillColor, surface, length, tolerance);&#13;
&#13;
        if (compareResult.canFill) {&#13;
            for(var j = i; j &lt; i + 4; j++) {&#13;
                presenter.allColoredPixels.push(j);&#13;
            }&#13;
            //fill the color&#13;
            surface[i]     = fillColor[0];&#13;
            surface[i + 1] = fillColor[1];&#13;
            surface[i + 2] = fillColor[2];&#13;
            surface[i + 3] = fillColor[3];&#13;
&#13;
            return true;&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return;&#13;
        }&#13;
        presenter.setShowErrorsModeActive = false;&#13;
&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.currentScore = presenter.getScore();&#13;
        presenter.currentErrorCount = presenter.getErrorCount();&#13;
&#13;
        presenter.tmpFilledAreas = [];&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            if (presenter.shouldBeTakenIntoConsideration(this)) {&#13;
                presenter.tmpFilledAreas.push({&#13;
                    area: this,&#13;
                    color: presenter.getColorAtPoint(this.x, this.y)&#13;
                });&#13;
            }&#13;
&#13;
        });&#13;
&#13;
        if (presenter.configuration.userAreas) {&#13;
            for (var i = 0; i &lt; presenter.configuration.userAreas.length; i++) {&#13;
                var area = presenter.configuration.userAreas[i];&#13;
                presenter.tmpFilledAreas.push({area: area, color: area.getColor()});&#13;
            }&#13;
        }&#13;
&#13;
        presenter.clearCanvas();&#13;
        presenter.recolorImage();&#13;
&#13;
        var areas = presenter.configuration.areas;&#13;
        for (var i=0; i&lt; areas.length; i++) {&#13;
            presenter.floodFill({&#13;
                    x: areas[i].x,&#13;
                    y: areas[i].y,&#13;
                    color: [255, 255, 255, 255]&#13;
                },&#13;
                [areas[i].colorToFill[0], areas[i].colorToFill[1], areas[i].colorToFill[2], areas[i].colorToFill[3]],&#13;
                presenter.configuration.tolerance);&#13;
&#13;
            presenter.allColoredPixels = [];&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.clearCanvas();&#13;
        presenter.recolorImage();&#13;
        $.each(presenter.tmpFilledAreas, function() {&#13;
            presenter.floodFill({&#13;
                    x: this.area.x,&#13;
                    y: this.area.y,&#13;
                    color: [255, 255, 255, 255]&#13;
                },&#13;
                this.color,&#13;
                presenter.configuration.tolerance);&#13;
&#13;
            presenter.allColoredPixels = [];&#13;
        });&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>