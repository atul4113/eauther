<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Table" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Rows" nameLabel="Table_property_rows" type="string"/>
		<property name="Columns" nameLabel="Table_property_columns" type="string"/>
		<property isDefault="true" name="Table cells" nameLabel="Table_property_table_cells" type="list">
			<property name="Row" nameLabel="Table_property_row" type="string"/>
			<property name="Column" nameLabel="Table_property_column" type="string"/>
			<property isLocalized="true" name="Content" nameLabel="Table_property_content" type="html"/>
            <property name="CSS Class" nameLabel="Table_property_css_class" type="string"/>
            <property name="CSS Style" nameLabel="Table_property_css_style" type="string"/>
		</property>
		<property name="Columns width" nameLabel="Table_property_columns_width" type="list">
			<property name="Width" nameLabel="Table_property_width" type="string"/>
		</property>
		<property name="Rows height" nameLabel="Table_property_rows_height" type="list">
			<property name="Height" nameLabel="Table_property_height" type="string"/>
		</property>
		<property name="Is not an activity" nameLabel="Table_property_is_not_an_activity" type="boolean"/>
		<property name="Is disabled" nameLabel="Table_property_is_disabled" type="boolean"/>
		<property name="Case sensitive" nameLabel="Table_property_case_sensitive" type="boolean"/>
		<property name="Ignore punctuation" nameLabel="Table_property_ignore_punctuation" type="boolean"/>
		<property name="Gap width" nameLabel="Table_property_gap_width" type="string"/>
        <property name="Gap Type" nameLabel="Table_property_gap_type" type="{editable, draggable, math}"/>
		<property name="newWidthCalculate" nameLabel="Table_property_new_width_calculate" type="boolean"/>
		<property displayName="Lang attribute" name="langAttribute" nameLabel="Table_property_lang_attribute" type="string"/>
		<property displayName="Speech texts" name="speechTexts" nameLabel="Hierarchical_Lesson_Report_property_speech_texts" type="staticlist">

            <property name="Correct" nameLabel="choice_item_correct" type="staticrow">
                <property name="Correct" nameLabel="choice_item_correct" type="string"/>
            </property>

			<property name="Wrong" nameLabel="choice_item_wrong" type="staticrow">
                <property name="Wrong" nameLabel="choice_item__wrong" type="string"/>
            </property>

			<property name="Empty" nameLabel="choice_item_empty" type="staticrow">
                <property name="Empty" nameLabel="choice_item_empty" type="string"/>
            </property>

			<property name="Gap" nameLabel="choice_item_gap" type="staticrow">
                <property name="Gap" nameLabel="choice_item_gap" type="string"/>
            </property>

			<property name="Dropdown" nameLabel="choice_item_dropdown" type="staticrow">
                <property name="Dropdown" nameLabel="choice_item_dropdown" type="string"/>
            </property>

			<property name="Inserted" nameLabel="text_insert" type="staticrow">
                <property name="Inserted" nameLabel="text_insert" type="string"/>
            </property>

			<property name="Removed" nameLabel="text_removed" type="staticrow">
                <property name="Removed" nameLabel="text_removed" type="string"/>
            </property>

			<property name="Cell" nameLabel="Table_cell" type="staticrow">
                <property name="Cell" nameLabel="Table_cell" type="string"/>
            </property>

		</property>
	</model>
<css>.table-addon-wrapper {&#13;
    border: 0;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    direction: ltr;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    direction: ltr;&#13;
}&#13;
&#13;
.table-addon-wrapper table {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    border-collapse: collapse;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.table-addon-wrapper table td {&#13;
    padding-left: 10px;&#13;
    padding-right: 10px;&#13;
    text-align: center;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.table-addon-wrapper table tr td {&#13;
    border: 1px solid black;&#13;
}&#13;
&#13;
.table-addon-wrapper .gapFilled{&#13;
    cursor: pointer;&#13;
}&#13;
&#13;
.table-addon-wrapper .draggable-gap{&#13;
    height: 20px;&#13;
    width: 40px;&#13;
}&#13;
</css><view>&lt;div class="table-addon-wrapper"&gt;&lt;/div&gt;&#13;
</view><preview>&lt;div class="table-addon-wrapper"&gt;&lt;/div&gt;&#13;
</preview><presenter>function AddonTable_create() {&#13;
&#13;
    /*&#13;
        INTEGRATION WITH MATH MODULE:&#13;
            Table supports integration with Math module. Table which is not activity, will show answers provided by&#13;
            Math module. Requires implementation of methods and variables listed below.&#13;
&#13;
            Attributes:&#13;
                @param isConnectedWith {boolean}  required by Math module, to detect if table is connected with Math&#13;
&#13;
            Methods:&#13;
                presenter.setGapAnswer (gapIndex, answer, answersLength) - method used by Math to set gap answer at&#13;
                    show answers when table is not activity. Gap index based by DOM occurence order. 1-n based&#13;
&#13;
                presenter.setUserValue (gapIndex, value) - method used by Math module to restore user answer at hide answers&#13;
&#13;
                presenter.getValue (gapIndex) - method used by Math module to get user value in gap by index&#13;
&#13;
                presenter.isActivity - method used by Math module to determine if addon is activity&#13;
     */&#13;
&#13;
&#13;
    var presenter = function () {&#13;
    };&#13;
&#13;
    var isConnectedWithMath = false;&#13;
    presenter.gapsSize = [];&#13;
    presenter.isSetShowErrorsMode = false;&#13;
    presenter.keyboardControllerObject = null;&#13;
    presenter.isWCAGOn = false;&#13;
    presenter.gapNavigation = false;&#13;
    presenter.addonKeyboardNavigationActive = false;&#13;
    presenter.gapIndex = 0;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'RW_01': 'Number of rows must be a positive integer!',&#13;
        'CL_01': 'Number of columns must be a positive integer!',&#13;
        'CO_01': 'Row number must be a positive integer!',&#13;
        'CO_02': 'Column number must be a positive integer',&#13;
        'CO_03': 'Row number must be a number from 1 to rows count!',&#13;
        'CO_04': 'Column number must be a number from 1 to columns count',&#13;
        'CO_05': 'Each table cell can be defined only once!',&#13;
        'CO_06': 'Empty table cell definition must contain only one empty element!',&#13;
        'CR_00': 'Column and row numbers must be sequential within one table cell',&#13;
        'CW_01': "Number of items in 'Columns width' property cannot be higher than number of columns!",&#13;
        'RH_01': "Number of items in 'Rows height' property cannot be higher than number of rows!",&#13;
        'GW_01': "Gap width incorrect!"&#13;
    };&#13;
&#13;
    presenter.replaceGapID = function (gap, parsedText) {&#13;
        var gapID = presenter.configuration.addonID + gap.id;&#13;
        var patt = new RegExp("id=\"" + gap.id + "\"");&#13;
        var rep = "id=\"" + gapID + "\"";&#13;
        return  parsedText.replace(patt, rep);&#13;
    };&#13;
&#13;
    function getParsedHTMLView () {&#13;
        return presenter.textParser.parseGaps(presenter.$view.html(),&#13;
            { isCaseSensitive: presenter.configuration.isCaseSensitive }&#13;
        );&#13;
    }&#13;
&#13;
    presenter.parseGaps = function (isPreview) {&#13;
        if (presenter.configuration.gapType == "draggable") {&#13;
            return presenter.parseGapsWrapper(presenter.DraggableDroppableGap, isPreview);&#13;
        } else {&#13;
            return presenter.parseGapsWrapper(presenter.EditableInputGap, isPreview);&#13;
        }&#13;
    };&#13;
&#13;
    function changeInlineGapsIDs (inlineGaps, parsedText) {&#13;
        inlineGaps.forEach(function (gap) {&#13;
            parsedText = presenter.replaceGapID(gap, parsedText);&#13;
            var gapID = presenter.configuration.addonID + gap.id;&#13;
&#13;
            presenter.gapsContainer.addGap(new presenter.SelectGap(gapID, [gap.answer], gap.value));&#13;
        });&#13;
&#13;
        return parsedText;&#13;
    }&#13;
&#13;
    function changeSimpleGapsIDs (simpleGaps, parsedText, objectType) {&#13;
        simpleGaps.forEach(function (gap) {&#13;
            parsedText = presenter.replaceGapID(gap, parsedText);&#13;
            var gapID = presenter.configuration.addonID + gap.id;&#13;
            presenter.gapsContainer.addGap(new objectType(gapID, gap.answers, 1));&#13;
        });&#13;
&#13;
        return parsedText;&#13;
    }&#13;
&#13;
    presenter.parseGapsWrapper = function (objectType, isPreview) {&#13;
        var textParserResult = getParsedHTMLView();&#13;
&#13;
        var parsedText = textParserResult.parsedText;&#13;
        parsedText = changeSimpleGapsIDs(textParserResult.gaps, parsedText, objectType);&#13;
        parsedText = changeInlineGapsIDs(textParserResult.inLineGaps, parsedText, objectType);&#13;
&#13;
        presenter.$view.html(parsedText);&#13;
&#13;
        if(!isPreview){&#13;
            presenter.getInputsSize();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getInputsSize = function () {&#13;
        presenter.$view.find('input').each(function () {&#13;
            var inputID = $(this).attr('id'),&#13;
                inputSize = $(this).attr('size');&#13;
&#13;
            presenter.gapsSize.push({id : inputID, size: inputSize})&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setGapsClassAndWidth = function () {&#13;
        presenter.$view.find('.ic_inlineChoice').addClass('ic_gap');&#13;
        presenter.$view.find('.ic_inlineChoice').css('width', presenter.configuration.gapWidth.value+"px");&#13;
    };&#13;
&#13;
    presenter.initializeGaps = function (isPreview) {&#13;
        presenter.parseGaps(isPreview);&#13;
&#13;
        if(presenter.configuration.gapType == 'math'){&#13;
            presenter.gapsContainer.gaps = [];&#13;
            $(presenter.$view).find('input').each(function () {&#13;
                $(this).replaceWith("\\gap{" +&#13;
                    $(this).attr('id') +&#13;
                    "|" +&#13;
                    1 +&#13;
                    "|" +&#13;
                    presenter.configuration.gapWidth.value +&#13;
                    "|" +&#13;
                    "{{value:" + $(this).attr('id') + "}}" +&#13;
                    "}");&#13;
            });&#13;
        }&#13;
&#13;
        presenter.gapsContainer.replaceDOMViewWithGap();&#13;
        presenter.setGapsClassAndWidth();&#13;
    };&#13;
&#13;
    function deleteCommands () {&#13;
        delete presenter.getScore;&#13;
        delete presenter.getMaxScore;&#13;
        delete presenter.getState;&#13;
        delete presenter.setState;&#13;
        delete presenter.getGapTextCommand;&#13;
        delete presenter.getGapTextCommand;&#13;
        delete presenter.markGapAsEmptyCommand;&#13;
        delete presenter.markGapAsCorrectCommand;&#13;
        delete presenter.markGapAsWrongCommand;&#13;
        delete presenter.enableGapCommand;&#13;
        delete presenter.enableAllGaps;&#13;
        delete presenter.disableGapCommand;&#13;
        delete presenter.disableAllGaps;&#13;
    }&#13;
&#13;
    function replaceInputsInPreview () {&#13;
        if (presenter.configuration.gapType == "draggable") {&#13;
            var inputs = presenter.$wrapper.find("input");&#13;
&#13;
            for (var i = 0; i &lt; inputs.length; i++) {&#13;
                $(inputs[i]).replaceWith(presenter.DraggableDroppableGap.prototype.createView());&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.logic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.$wrapper = presenter.$view.find('.table-addon-wrapper');&#13;
        presenter.configuration = presenter.validateModel(presenter.upgradeModel(model));&#13;
        presenter.isPreview = isPreview;&#13;
&#13;
        if(presenter.configuration.gapType == "math"){&#13;
            var mathJaxDeferred = new jQuery.Deferred();&#13;
            presenter.mathJaxProcessEndedDeferred = mathJaxDeferred;&#13;
            presenter.mathJaxProcessEnded = mathJaxDeferred.promise();&#13;
&#13;
            MathJax.Hub.Register.MessageHook("End Process", function (message) {&#13;
                if ($(message[1]).hasClass('ic_page')) {&#13;
                    presenter.mathJaxProcessEndedDeferred.resolve();&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            deleteCommands();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.mainLogic(isPreview);&#13;
&#13;
        if(presenter.configuration.gapType == "math"){&#13;
            presenter.mathJaxProcessEnded.then(function() {&#13;
                MathJax.CallBack.Queue().Push(function () {&#13;
                    if(!isPreview){&#13;
                        MathJax.Hub.Typeset(presenter.$view.find(".table-addon-wrapper")[0]);&#13;
                        presenter.keyboardControllerObject.setElements(presenter.getElementsForKeyboardNavigation());&#13;
                        var checkSelector = setInterval(function () {&#13;
                            if ($(presenter.$view).find('input').length &gt; 0) {&#13;
                                presenter.gapsContainer.gaps = [];&#13;
                                $(presenter.$view).find('input').each(function (_, index) {&#13;
                                    for(var i = 0; i &lt; presenter.gapsAnswers.length; i++){&#13;
                                        if(presenter.gapsAnswers[i].id == $(this).attr('id')){&#13;
                                            var correctAnswers = presenter.gapsAnswers[i].answers;&#13;
                                        }&#13;
                                    }&#13;
                                    presenter.gapsContainer.addGap(new presenter.EditableInputGap($(this).attr('id'), correctAnswers, 1));&#13;
                                });&#13;
                                clearInterval(checkSelector);&#13;
                                presenter.eventBus.sendEvent('ValueChanged', []);&#13;
                            }&#13;
                        }, 100);&#13;
                    }&#13;
                });&#13;
            });&#13;
        }&#13;
&#13;
        if(isPreview) {&#13;
            presenter.setEditorGapWidth();&#13;
        } else {&#13;
            presenter.setInputsSize();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setInputsSize = function () {&#13;
        for (var i = 0; i &lt; presenter.gapsSize.length; i++) {&#13;
            var inputId = presenter.gapsSize[i].id,&#13;
                size = presenter.gapsSize[i].size;&#13;
&#13;
            presenter.$view.find('#'+inputId).attr('size', size);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setEditorGapWidth = function () {&#13;
        presenter.$view.find('input').css("width", presenter.configuration.gapWidth.value+"px");&#13;
        presenter.$view.find('span').css("width", presenter.configuration.gapWidth.value+"px");&#13;
    };&#13;
&#13;
    presenter.mainLogic = function (isPreview) {&#13;
        presenter.gapsContainer = new presenter.GapsContainerObject();&#13;
&#13;
        var $table = presenter.generateTable(presenter.configuration.contents, isPreview);&#13;
        presenter.setColumnWidth($table, presenter.configuration.columnsWidths, presenter.configuration.rowsHeights);&#13;
        presenter.setRowHeight($table, presenter.configuration.rowsHeights);&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        presenter.initializeGaps(isPreview);&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.parseDefinitionLinks();&#13;
        } else {&#13;
            replaceInputsInPreview();&#13;
            presenter.setGapsClassAndWidth();&#13;
            presenter.$view.find('input').attr("size", "auto");&#13;
            if (presenter.configuration.gapType == "draggable") {&#13;
                presenter.$view.find('input').addClass("draggable-gap");&#13;
            }&#13;
        }&#13;
&#13;
        presenter.gapsContainer.replaceGapsDOMWithView();&#13;
        presenter.lastDraggedItem = {};&#13;
&#13;
        if (presenter.configuration.isDisabledByDefault) {&#13;
            presenter.gapsContainer.lockAllGaps();&#13;
        }&#13;
&#13;
        presenter.buildKeyboardController();&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
        presenter.textParser = new TextParserProxy(controller.getTextParser());&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
        presenter.eventBus.addEventListener('ItemSelected', this);&#13;
    };&#13;
&#13;
    presenter.setTextParser = function (textParser) {&#13;
        presenter.textParser = new TextParserProxy(textParser());&#13;
    };&#13;
&#13;
    presenter.getSelectedItem = function () {&#13;
        var item = presenter.lastDraggedItem;&#13;
&#13;
        presenter.lastDraggedItem = {};&#13;
&#13;
        return item;&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.logic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.logic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.gapsContainer.reset();&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.isSetShowErrorsMode = false;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if(isConnectedWithMath){&#13;
            presenter.gapsContainer.unlockAllGaps();&#13;
        }&#13;
&#13;
        var spans;&#13;
        var gaps = presenter.gapsContainer.getGapsState();&#13;
&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            spans = presenter.gapsContainer.getState();&#13;
        } else {&#13;
            spans = null;&#13;
        }&#13;
&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            gaps: gaps,&#13;
            spans: spans&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (rawState) {&#13;
        var state = JSON.parse(rawState);&#13;
&#13;
        presenter.setVisibility(state.isVisible);&#13;
        presenter.configuration.isVisible = state.isVisible;&#13;
&#13;
        if(presenter.configuration.gapType == 'math'){&#13;
            var checkSelector = setInterval(function () {&#13;
                if ($(presenter.$view).find('.mathGap').length == presenter.gapsAnswers.length) {&#13;
                    try{&#13;
                    presenter.gapsContainer.setGapsState(state.gaps);&#13;
                    presenter.gapsContainer.setSpansState(state.spans);&#13;
                    clearInterval(checkSelector);&#13;
                    }catch(e){}&#13;
                }&#13;
            }, 100);&#13;
        }else{&#13;
            presenter.gapsContainer.setGapsState(state.gaps);&#13;
            presenter.gapsContainer.setSpansState(state.spans);&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Generate table row (tr) element. Each cell has col_C and row_R classes where R is row number&#13;
     * (counted from 1 to rows count) and C is column number (from 1 to columns count).&#13;
     *&#13;
     * @param row row number counted from 0&#13;
     * @param content row content array&#13;
     * @param isPreview&#13;
     *&#13;
     * @return {jQuery} jQuery reference to new table row element&#13;
     */&#13;
    presenter.generateRow = function (row, content, isPreview) {&#13;
        var $rowElement = $(document.createElement('tr')), i, length;&#13;
&#13;
        for (i = 0, length = content.length; i &lt; length; i++) {&#13;
            if (!content[i]) continue;&#13;
&#13;
            var $element = $(document.createElement('td'));&#13;
&#13;
            $element.addClass('row_' + (row + 1));&#13;
            $element.addClass('col_' + (i + 1));&#13;
            $element.html(content[i].content);&#13;
            $element.attr({&#13;
                colspan: content[i].colSpan,&#13;
                rowspan: content[i].rowSpan&#13;
            });&#13;
&#13;
            if ( presenter.configuration.isTabindexEnabled) {&#13;
                $element.attr('tabindex', '0');&#13;
            }&#13;
&#13;
            if (content[i].class) {&#13;
                $element.addClass(content[i].class)&#13;
            }&#13;
            if (content[i].style) {&#13;
                $element.attr({style:content[i].style})&#13;
            }&#13;
&#13;
            $rowElement.append($element);&#13;
        }&#13;
&#13;
        return $rowElement;&#13;
    };&#13;
&#13;
    presenter.parseDefinitionLinks = function () {&#13;
        $.each(presenter.$view.find('td'), function (index, element) {&#13;
            $(element).html(presenter.textParser.parse($(element).html()));&#13;
        });&#13;
&#13;
        presenter.textParser.connectLinks(presenter.$view);&#13;
    };&#13;
&#13;
    /**&#13;
     * Generate table element with content based on provided array.&#13;
     *&#13;
     * @param content array with table cells contents&#13;
     * @param isPreview&#13;
     *&#13;
     * @return {jQuery} jQuery reference to new table element&#13;
     */&#13;
    presenter.generateTable = function (content, isPreview) {&#13;
        var $table = $(document.createElement('table'));&#13;
&#13;
        for (var i = 0, length = content.length; i &lt; length; i++) {&#13;
            var $row = presenter.generateRow(i, content[i], isPreview);&#13;
&#13;
            $table.append($row);&#13;
        }&#13;
&#13;
        presenter.$wrapper.html($table);&#13;
&#13;
        return $table;&#13;
    };&#13;
&#13;
    presenter.setColumnWidth = function ($table, columnWidth, rowsHeights) {&#13;
        var i = 0;&#13;
        if (presenter.configuration.newWidthCalculate) {&#13;
            var rowsNumber = rowsHeights.length;&#13;
            var columsNumber = columnWidth.length;&#13;
            for (var row = 1; row &lt;= rowsNumber; row++) {&#13;
                var foundedRow = $table.find('.row_' + row);&#13;
                for (i = 0; i &lt; columsNumber; i++) {&#13;
                    $(foundedRow[i]).css('width', columnWidth[i]);&#13;
                }&#13;
            }&#13;
        } else {&#13;
            var firstRow = $table.find('.row_1');&#13;
&#13;
            for (i = 0; i &lt; columnWidth.length; i++) {&#13;
                $(firstRow[i]).css('width', columnWidth[i]);&#13;
            }&#13;
        }&#13;
};&#13;
&#13;
&#13;
    presenter.setRowHeight = function ($table, rowHeight) {&#13;
        var i;&#13;
        for (i = 0; i &lt; rowHeight.length; i++) {&#13;
            $table.find('.row_' + (i + 1)).each(function () {&#13;
                $(this).css('height', rowHeight[i]);&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Validate content list and convert it into multidimensional {Array}. Not specified contents equals empty elements.&#13;
     *&#13;
     * @param content list of content definition (consist Row, Column and Content fields)&#13;
     * @param rowsCount number of rows&#13;
     * @param columnsCount number of columns&#13;
     *&#13;
     * @return {Object} validation result&#13;
     * @return {Boolean} isValid&#13;
     * @return {String} error code if any occurs&#13;
     * @return {Array} contents array of contents. Dimensions based on Rows and Columns properties&#13;
     */&#13;
    presenter.validateContent = function (content, rowsCount, columnsCount) {&#13;
        var validatedContent = [], controlArray = [], c, r;&#13;
&#13;
        for (r = 0; r &lt; rowsCount; r++) {&#13;
            validatedContent[r] = [];&#13;
            controlArray[r] = [];&#13;
&#13;
            for (c = 0; c &lt; columnsCount; c++) {&#13;
                validatedContent[r][c] = { content: "", rowSpan: 1, colSpan: 1 };&#13;
                controlArray[r][c] = false;&#13;
            }&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isArrayElementEmpty(content[0])) {&#13;
            if (content.length === 1) {&#13;
                return { isValid: true, content: validatedContent };&#13;
            } else {&#13;
                return { isValid: false, errorCode: 'CO_06' };&#13;
            }&#13;
        }&#13;
&#13;
        for (var i = 0, length = content.length; i &lt; length; i++) {&#13;
            var rows = presenter.validateSequence(content[i].Row, rowsCount, true);&#13;
            if (!rows.isValid)  return { isValid: false, errorCode: rows.errorCode };&#13;
&#13;
            var columns = presenter.validateSequence(content[i].Column, columnsCount, false);&#13;
            if (!columns.isValid)  return { isValid: false, errorCode: columns.errorCode };&#13;
&#13;
            for (r = 0; r &lt; rows.values.length; r++) {&#13;
                for (c = 0; c &lt; columns.values.length; c++) {&#13;
                    var row = rows.values[r] - 1;&#13;
                    var column = columns.values[c] - 1;&#13;
&#13;
                    if (controlArray[row][column]) return { isValid: false, errorCode: 'CO_05' };&#13;
                    controlArray[row][column] = true;&#13;
&#13;
                    if (r === 0 &amp;&amp; c == 0) {&#13;
                        validatedContent[row][column] = {&#13;
                            content: content[i].Content,&#13;
                            rowSpan: rows.values.length,&#13;
                            colSpan: columns.values.length,&#13;
                            class : content[i].hasOwnProperty("CSS Class") ? content[i]["CSS Class"] : "",&#13;
                            style: content[i].hasOwnProperty("CSS Style") ? content[i]["CSS Style"] : ""&#13;
                        };&#13;
                    } else {&#13;
                        validatedContent[row][column] = undefined;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return { isValid: true, content: validatedContent };&#13;
    };&#13;
&#13;
    presenter.validateSingleNumber = function (column, columnsCount, isRowValidated) {&#13;
        var validatedColumn = ModelValidationUtils.validatePositiveInteger(column);&#13;
&#13;
        if (!validatedColumn.isValid) return { isValid: false, errorCode: isRowValidated ? 'CO_01' : 'CO_02'};&#13;
        if (validatedColumn.value &gt; columnsCount) return { isValid: false, errorCode: isRowValidated ? 'CO_03' : 'CO_04' };&#13;
&#13;
        return {isValid: true, value: validatedColumn.value };&#13;
    };&#13;
&#13;
    presenter.validateSequence = function (columns, columnsCount, isRowValidated) {&#13;
        var values = [], validatedColumn, splittedColumns, i;&#13;
&#13;
        splittedColumns = columns.indexOf(',') === -1 ? [columns] : columns.split(',');&#13;
&#13;
        for (i = 0; i &lt; splittedColumns.length; i++) {&#13;
            validatedColumn = presenter.validateSingleNumber(splittedColumns[i], columnsCount, isRowValidated);&#13;
&#13;
            if (!validatedColumn.isValid) return { isValid: false, errorCode: validatedColumn.errorCode };&#13;
&#13;
            values.push(validatedColumn.value);&#13;
        }&#13;
&#13;
        if (values.length &gt; 1) {&#13;
            for (i = 1; i &lt; values.length; i++) {&#13;
                if (values[i - 1] + 1 !== values[i]) {&#13;
                    return { isValid: false, errorCode: 'CR_00' };&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return { values: values, isValid: true };&#13;
    };&#13;
&#13;
    presenter.convertDimensionsArray = function (columnWidth, columnsCount, propertyName) {&#13;
        if (columnWidth.length &gt; columnsCount) return { isValid: false };&#13;
&#13;
        var widths = [], value, i;&#13;
        for (i = 0; i &lt; columnWidth.length; i++) {&#13;
            if (ModelValidationUtils.isStringEmpty(columnWidth[i][propertyName])) {&#13;
                value = 'auto';&#13;
            } else {&#13;
                value = columnWidth[i][propertyName];&#13;
            }&#13;
&#13;
            widths.push(value);&#13;
        }&#13;
&#13;
        if (columnWidth.length &lt; columnsCount) {&#13;
            for (i = columnWidth.length; i &lt; columnsCount; i++) {&#13;
                widths.push('auto');&#13;
            }&#13;
        }&#13;
&#13;
        return { isValid: true, dimensions: widths };&#13;
    };&#13;
&#13;
    function getSpeechTextProperty (rawValue, defaultValue) {&#13;
        var value = rawValue.trim();&#13;
&#13;
        if (value === undefined || value === null || value === '') {&#13;
            return defaultValue;&#13;
        }&#13;
&#13;
        return value;&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            correct:  'correct',&#13;
            wrong: 'wrong',&#13;
            empty: 'empty',&#13;
            gap: 'gap',&#13;
            dropdown: 'dropdown',&#13;
            inserted: 'inserted',&#13;
            removed: 'removed',&#13;
            cell: 'cell'&#13;
        };&#13;
&#13;
        if (!speechTexts) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            correct:    getSpeechTextProperty(speechTexts['Correct']['Correct'], presenter.speechTexts.correct),&#13;
            wrong: getSpeechTextProperty(speechTexts['Wrong']['Wrong'], presenter.speechTexts.wrong),&#13;
            empty:  getSpeechTextProperty(speechTexts['Empty']['Empty'], presenter.speechTexts.empty),&#13;
            gap:     getSpeechTextProperty(speechTexts['Gap']['Gap'], presenter.speechTexts.gap),&#13;
            dropdown:   getSpeechTextProperty(speechTexts['Dropdown']['Dropdown'], presenter.speechTexts.dropdown),&#13;
            inserted:      getSpeechTextProperty(speechTexts['Inserted']['Inserted'], presenter.speechTexts.inserted),&#13;
            removed:        getSpeechTextProperty(speechTexts['Removed']['Removed'], presenter.speechTexts.removed),&#13;
            cell:        getSpeechTextProperty(speechTexts['Cell']['Cell'], presenter.speechTexts.cell)&#13;
        };&#13;
    };&#13;
&#13;
    /**&#13;
     * Validate user input configuration.&#13;
     *&#13;
     * @param model {Array} of properties injected into Addon&#13;
     *&#13;
     * @return {Object} validation result&#13;
     * @return {Boolean} isValid&#13;
     * @return {String} error code if any occurs&#13;
     * @return {Object} contents array of contents. Dimensions based on Rows and Columns properties&#13;
     */&#13;
    presenter.validateModel = function (model) {&#13;
&#13;
        presenter.setSpeechTexts(model['speechTexts']);&#13;
&#13;
        if (model["newWidthCalculate"] === undefined) {&#13;
            model["newWidthCalculate"] = false;&#13;
        }&#13;
&#13;
        var validatedRows = ModelValidationUtils.validatePositiveInteger(model.Rows);&#13;
        if (!validatedRows.isValid) {&#13;
            return { isValid: false, errorCode: 'RW_01' };&#13;
        }&#13;
&#13;
        var validatedColumns = ModelValidationUtils.validatePositiveInteger(model.Columns);&#13;
        if (!validatedColumns.isValid) {&#13;
            return { isValid: false, errorCode: 'CL_01' };&#13;
        }&#13;
&#13;
        var validatedContents = presenter.validateContent(model["Table cells"], validatedRows.value, validatedColumns.value);&#13;
        if (!validatedContents.isValid) {&#13;
            return { isValid: false, errorCode: validatedContents.errorCode };&#13;
        }&#13;
&#13;
        var convertedColumnWidth = presenter.convertDimensionsArray(model["Columns width"], validatedColumns.value, 'Width');&#13;
        if (!convertedColumnWidth.isValid) {&#13;
            return { isValid: false, errorCode: 'CW_01' };&#13;
        }&#13;
&#13;
        var convertedRowWidths = presenter.convertDimensionsArray(model["Rows height"], validatedRows.value, 'Height');&#13;
        if (!convertedRowWidths.isValid) {&#13;
            return { isValid: false, errorCode: 'RH_01' };&#13;
        }&#13;
&#13;
        var gapWidth = { isSet: false, value: undefined };&#13;
        if (!ModelValidationUtils.isStringEmpty(model["Gap width"])) {&#13;
            var validatedGapWidth = ModelValidationUtils.validatePositiveInteger(model["Gap width"]);&#13;
            if (!validatedGapWidth.isValid) {&#13;
                return { isValid: false, errorCode: 'GW_01' };&#13;
            } else {&#13;
                gapWidth = { isSet: true, value: validatedGapWidth.value };&#13;
            }&#13;
        }&#13;
&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        var isTabindexEnabled = ModelValidationUtils.validateBoolean(model['Is Tabindex Enabled']);&#13;
&#13;
        return {&#13;
            addonID: model.ID,&#13;
            isValid: true,&#13;
            contents: validatedContents.content,&#13;
            columnsWidths: convertedColumnWidth.dimensions,&#13;
            rowsHeights: convertedRowWidths.dimensions,&#13;
            isVisible: isVisible,&#13;
            isVisibleByDefault: isVisible,&#13;
            isActivity: !ModelValidationUtils.validateBoolean(model["Is not an activity"]),&#13;
            isNotActivity: ModelValidationUtils.validateBoolean(model["Is not an activity"]),&#13;
            isDisabledByDefault: ModelValidationUtils.validateBoolean(model["Is disabled"]),&#13;
            isPunctuationIgnored: ModelValidationUtils.validateBoolean(model["Ignore punctuation"]),&#13;
            isCaseSensitive: ModelValidationUtils.validateBoolean(model["Case sensitive"]),&#13;
            newWidthCalculate: ModelValidationUtils.validateBoolean(model["newWidthCalculate"]),&#13;
            gapWidth: gapWidth,&#13;
            gapType: model["Gap Type"],&#13;
            isTabindexEnabled: isTabindexEnabled,&#13;
            columnsCount: validatedColumns.value,&#13;
            rowsCount: validatedRows.value,&#13;
            langTag: model["langAttribute"]&#13;
        };&#13;
    };&#13;
&#13;
    presenter.addColumnsWidth = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model["Columns width"]) {&#13;
            upgradedModel["Columns width"] = [&#13;
                { Width: "" }&#13;
            ];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addRowHeights = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model["Rows height"]) {&#13;
            upgradedModel["Rows height"] = [&#13;
                { Height: "" }&#13;
            ];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addLangTag = function AddonTable_addLangTag(model) {&#13;
         var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model['langAttribute']) {&#13;
            upgradedModel['langAttribute'] =  '';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addSpeechTexts = function(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model['speechTexts']) {&#13;
            upgradedModel['speechTexts'] = {&#13;
                Gap: {Gap: "Gap"},&#13;
                Dropdown: {Dropdown: "Dropdown"},&#13;
                Correct: {Correct: "Correct"},&#13;
                Wrong: {Wrong: "Wrong"},&#13;
                Empty: {Empty: "Empty"},&#13;
                Inserted: {Inserted: "Inserted"},&#13;
                Removed: {Removed: "Removed"},&#13;
                Cell: {Cell: "Cell"}&#13;
            }&#13;
        }&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        var upgradedModel = presenter.addColumnsWidth(model);&#13;
        upgradedModel = presenter.addRowHeights(upgradedModel);&#13;
        upgradedModel = presenter.addLangTag(upgradedModel);&#13;
        upgradedModel = presenter.addSpeechTexts(upgradedModel);&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.getGapText = function (gapIndex) {&#13;
        return executeFunctionOnGap(gapIndex, "getGapValueByIndex");&#13;
    };&#13;
&#13;
    presenter.getGapValue = function (gapIndex) {&#13;
        return presenter.getGapText(gapIndex);&#13;
    };&#13;
&#13;
    presenter.getGapTextCommand = function (params) {&#13;
        return presenter.getGapText(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    function executeFunctionOnGap(gapIndex, functionToCall) {&#13;
        var validatedGapIndex = presenter.validateGapIndex(gapIndex);&#13;
&#13;
        if (validatedGapIndex.isValid) {&#13;
            return presenter.gapsContainer[functionToCall](validatedGapIndex.index);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.validateGapIndex = function (gapIndex) {&#13;
        if (isNaN(gapIndex) || gapIndex &lt; 1 || gapIndex &gt; presenter.gapsContainer.getLength()) {&#13;
            return {isValid: false};&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            index: parseInt(gapIndex, 10) - 1&#13;
        };&#13;
    };&#13;
&#13;
&#13;
    presenter.markGapAsCorrect = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsCorrect");&#13;
    };&#13;
&#13;
    presenter.markGapAsCorrectCommand = function (params) {&#13;
        presenter.markGapAsCorrect(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.markGapAsWrong = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsWrong");&#13;
    };&#13;
&#13;
    presenter.markGapAsWrongCommand = function (params) {&#13;
        presenter.markGapAsWrong(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.markGapAsEmpty = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsEmpty");&#13;
    };&#13;
&#13;
    presenter.markGapAsEmptyCommand = function (params) {&#13;
        presenter.markGapAsEmpty(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.enableGap = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "unlockGapByIndex");&#13;
    };&#13;
&#13;
    presenter.enableGapCommand = function (params) {&#13;
        presenter.enableGap(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.enableAllGaps = function () {&#13;
        presenter.gapsContainer.unlockAllGaps();&#13;
    };&#13;
&#13;
    presenter.disableGap = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "lockGapByIndex");&#13;
    };&#13;
&#13;
    presenter.disableGapCommand = function (params) {&#13;
        presenter.disableGap(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.disableAllGaps = function () {&#13;
        presenter.gapsContainer.lockAllGaps();&#13;
    };&#13;
&#13;
    presenter.getView = function() {&#13;
        return presenter.$view;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function() {&#13;
        var score = presenter.getScore();&#13;
        return score == presenter.getMaxScore() &amp;&amp; score != 0;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'getGapText': presenter.getGapTextCommand,&#13;
            'getGapValue': presenter.getGapTextCommand,&#13;
            'markGapAsEmpty': presenter.markGapAsEmptyCommand,&#13;
            'markGapAsCorrect': presenter.markGapAsCorrectCommand,&#13;
            'markGapAsWrong': presenter.markGapAsWrongCommand,&#13;
            'enableGap': presenter.enableGapCommand,&#13;
            'enableAllGaps': presenter.enableAllGaps,&#13;
            'disableGap': presenter.disableGapCommand,&#13;
            'disableAllGaps': presenter.disableAllGaps,&#13;
            'getView' : presenter.getView,&#13;
            'isAllOK' : presenter.isAllOK&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.sendAllOKEvent = function () {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer == undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getMaxScore();&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer == undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getScore();&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer == undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getErrorCount();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if (!presenter.isSetShowErrorsMode) {&#13;
            presenter.gapsContainer.check();&#13;
            presenter.isSetShowErrorsMode = true;&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            presenter.gapsContainer.unlockAllGaps();&#13;
            presenter.gapsContainer.lockAllNotEmptyGaps();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        if (presenter.isSetShowErrorsMode) {&#13;
            presenter.gapsContainer.check();&#13;
            presenter.isSetShowErrorsMode = false;&#13;
        }&#13;
&#13;
        presenter.gapsContainer.removeAllGapsClasses();&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            presenter.gapsContainer.unlockAllGaps();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        return {&#13;
            source: presenter.configuration.addonID,&#13;
            item: "" + item,&#13;
            value: "" + value,&#13;
            score: "" + score&#13;
        };&#13;
    };&#13;
    &#13;
    presenter.onEventReceived = function (eventName, eventData) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "ItemSelected") {&#13;
            presenter.lastDraggedItem = eventData;&#13;
        }&#13;
    };&#13;
    &#13;
    presenter.showAnswers = function () {&#13;
        if (presenter.configuration.isActivity) {&#13;
            presenter.gapsContainer.showAnswers();&#13;
            presenter.isShowAnswersActive = true;&#13;
            presenter.isSetShowErrorsMode = false;&#13;
            presenter.renderMathJax();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            presenter.gapsContainer.hideAnswers();&#13;
            if(isConnectedWithMath){&#13;
                presenter.gapsContainer.unlockAllGaps();&#13;
            }&#13;
            presenter.isShowAnswersActive = false;&#13;
            presenter.isSetShowErrorsMode = false;&#13;
            presenter.renderMathJax();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getCSSConfiguration = function () {&#13;
        return {&#13;
            correct: "ic_gap-correct",&#13;
            wrong: "ic_gap-wrong",&#13;
            showAnswers: "ic_gap-show-answers",&#13;
            block: "ic_gap-empty"&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils = function (configuration) {&#13;
        if(!presenter.isPreview){&#13;
            DraggableDroppableObject.call(this, configuration, presenter.getCSSConfiguration());&#13;
        }&#13;
&#13;
        this.gapScore = configuration.gapScore;&#13;
        this.gapType = presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        this.isDisabled = false;&#13;
        this.isEnabled = true;&#13;
        this.mathShowAnswersValue = "";&#13;
        this.mathCSSClass = "math-answer";&#13;
        this.valueChangeObserver = new presenter.ValueChangeObserver();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype = Object.create(DraggableDroppableObject.prototype);&#13;
    presenter.GapUtils.parent = DraggableDroppableObject.prototype;&#13;
&#13;
    presenter.GapUtils.GAP_TYPE = {&#13;
        NORMAL: 0,&#13;
        SELECT: 1&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getParsedCorrectAnswers = function () {&#13;
        return this.showAnswersValue.map(function (value) {&#13;
            return this.parseValue(value);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getParsedValue = function () {&#13;
        return this.parseValue(this.getValue());&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.isCorrect = function () {&#13;
        var correctAnswers = this.getParsedCorrectAnswers();&#13;
        var value = this.getParsedValue();&#13;
&#13;
        return (correctAnswers.indexOf(value) !== -1);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.parseValue = function (value) {&#13;
        if(presenter.configuration.gapType == 'math') {&#13;
            return value;&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isCaseSensitive) {&#13;
            value = value.toLowerCase();&#13;
        }&#13;
&#13;
        if (presenter.configuration.isPunctuationIgnored) {&#13;
            value = value.replace(/\W/g, '');&#13;
        }&#13;
&#13;
        return value;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.isValueEmpty = function () {&#13;
        var value = this.getValue().trim();&#13;
        return value.length === 0 || (this.gapType===1 &amp;&amp; 0 === value.localeCompare("---")); //gapType===1 is the dropdown gap&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnCorrect = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return true;&#13;
        }&#13;
&#13;
        DraggableDroppableObject.prototype.setCssOnCorrect.call(this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnUnCorrect = function () {&#13;
        this.removeAllClasses();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onBlock = function () {&#13;
        if (!this.isDisabled) {&#13;
            this.lock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnblock = function () {&#13;
        if (this.isDisabled &amp;&amp; this.isEnabled) {&#13;
            this.unlock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onCorrect = function () {&#13;
        this.onBlock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnCorrect = function () {&#13;
        this.onUnblock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onWrong = function () {&#13;
        this.onBlock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnWrong = function () {&#13;
        this.onUnblock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnWrong = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return true;&#13;
        }&#13;
&#13;
        if (this.isValueEmpty()) {&#13;
            this.addCssClass('ic_gap-empty');&#13;
            return;&#13;
        }&#13;
&#13;
        DraggableDroppableObject.prototype.setCssOnWrong.call(this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnUnWrong = function () {&#13;
        this.removeAllClasses();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnShowAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            DraggableDroppableObject.prototype.setCssOnShowAnswers.call(this);&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.addCssClass(this.mathCSSClass);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnHideAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            DraggableDroppableObject.prototype.setCssOnHideAnswers.call(this);&#13;
    	}&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.removeCssClass(this.mathCSSClass);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onShowAnswers = function () {&#13;
        if (presenter.configuration.isActivity) {&#13;
            this.onBlock();&#13;
            this.setViewValue(this.showAnswersValue[0]);&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.onBlock();&#13;
            this.setViewValue(this.mathShowAnswersValue);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onHideAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            this.setViewValue(this.value);&#13;
            this.onUnblock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setGapWidth = function () {&#13;
        if (presenter.configuration.gapWidth.isSet &amp;&amp; !presenter.isPreview) {&#13;
            this.$view.width(presenter.configuration.gapWidth.value + 'px');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.removeAllClasses = function () {&#13;
        this.removeCssClass('ic_gap-correct');&#13;
        this.removeCssClass('ic_gap-wrong');&#13;
        this.removeCssClass('ic_gap-empty');&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getScore = function () {&#13;
        return this.isCorrect() ? this.gapScore : 0;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getErrorCount = function () {&#13;
        if (this.getValue().trim() == "") {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return this.isCorrect() ? 0 : 1;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.notify = function () {&#13;
        this.valueChangeObserver.notify(this.getValueChangeEventData());&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getValueChangeEventData = function () {&#13;
        return {&#13;
            objectID: this.getObjectID(),&#13;
            isCorrect: this.isCorrect(),&#13;
            value: this.getValue()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setIsEnabled = function (isEnabled) {&#13;
        if (this.isDisabled &amp;&amp; isEnabled) {&#13;
            this.unlock();&#13;
        }&#13;
&#13;
        if (!this.isDisabled &amp;&amp; !isEnabled) {&#13;
            this.lock();&#13;
        }&#13;
&#13;
        this.isEnabled = isEnabled;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setMathShowAnswersValue = function (value) {&#13;
        this.mathShowAnswersValue = value;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getGapState = function () {&#13;
        return {&#13;
            value: this.getValue(),&#13;
            isEnabled: this.isEnabled&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getState = function () {&#13;
        return {&#13;
            value: this.getValue(),&#13;
            item: this.getSource(),&#13;
            droppedElement: this.getDroppedElement()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setState = function (value, source, isEnabled, droppedElement) {&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            DraggableDroppableObject.prototype.setState.call(this, value, source, droppedElement);&#13;
        } else {&#13;
            this.value = value;&#13;
            this.source = source;&#13;
            this.$view.val(value);&#13;
        }&#13;
&#13;
        if (isEnabled !== undefined) {&#13;
            this.setIsEnabled(isEnabled);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onReset = function () {&#13;
        DraggableDroppableObject.prototype.onReset.call(this);&#13;
&#13;
        if (presenter.configuration.isDisabledByDefault) {&#13;
            this.setIsEnabled(false);&#13;
        } else {&#13;
            this.setIsEnabled(true);&#13;
        }&#13;
&#13;
        this.removeAllClasses();&#13;
        this.removeCssClass("gapFilled");&#13;
    };&#13;
&#13;
&#13;
    presenter.SelectGap = function (htmlID, correctAnswer, gapScore) {&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
&#13;
            showAnswersValue: correctAnswer,&#13;
&#13;
            connectEvents: presenter.SelectGap.prototype.connectEvents,&#13;
            setViewValue: presenter.SelectGap.prototype.setViewValue,&#13;
&#13;
            gapScore: gapScore&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
&#13;
        this.gapType = presenter.GapUtils.GAP_TYPE.SELECT;&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.SelectGap.constructor = presenter.SelectGap;&#13;
&#13;
    presenter.SelectGap.prototype.connectEvents = function () {&#13;
        this.$view.off('change').bind('change', this.onEdit.bind(this));&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.onEdit = function (event) {&#13;
        this.notifyEdit();&#13;
        this.value = this.$view.find(":selected").text();&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.setViewValue = function (value) {&#13;
        this.$view.val(value);&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        this.$view.attr('disabled','disabled');&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        this.$view.removeAttr('disabled');&#13;
    };&#13;
&#13;
    presenter.gapsAnswers = [];&#13;
&#13;
    function addGapAnswers(htmlID, correctAnswer) {&#13;
        var isInTable = false;&#13;
        for (var i = 0; i &lt; presenter.gapsAnswers.length; i++){&#13;
            if(presenter.gapsAnswers[i].id == htmlID){&#13;
                isInTable = true;&#13;
            }&#13;
        }&#13;
&#13;
        if(!isInTable){&#13;
            presenter.gapsAnswers.push({id: htmlID, answers: correctAnswer});&#13;
        }&#13;
    }&#13;
&#13;
    presenter.EditableInputGap = function (htmlID, correctAnswer, gapScore) {&#13;
        addGapAnswers(htmlID, correctAnswer);&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
&#13;
            showAnswersValue: correctAnswer,&#13;
&#13;
            createView: presenter.EditableInputGap.prototype.createView,&#13;
            connectEvents: this.connectEvents,&#13;
            setViewValue: presenter.EditableInputGap.prototype.setViewValue,&#13;
&#13;
            gapScore: gapScore&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.EditableInputGap.constructor = presenter.EditableInputGap;&#13;
&#13;
    presenter.EditableInputGap.prototype.connectEvents = function () {&#13;
        this.$view.on("input", this.onEdit.bind(this));&#13;
        this.$view.on("blur", this.blurHandler.bind(this));&#13;
        this.$view.off('change').bind('change', this.onEdit.bind(this));&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.createView = function () {&#13;
        if(presenter.configuration.gapType == 'math'){&#13;
            return $(presenter.$view).find("input[id='"+this.objectID+"']");&#13;
        }else{&#13;
            var $inputGap = $('&lt;input type="text" value="" id="' + this.objectID + '" /&gt;');&#13;
            $inputGap.css({&#13;
                width: presenter.configuration.gapWidth + "px"&#13;
            });&#13;
&#13;
            $inputGap.addClass("ic_gap");&#13;
&#13;
            return $inputGap;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.onEdit = function (event) {&#13;
        this.notifyEdit();&#13;
        this.value = this.getViewValue();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.blurHandler = function (event) {&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.getViewValue = function () {&#13;
        return this.$view.val();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        this.$view.attr('disabled','disabled');&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        this.$view.removeAttr('disabled');&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.getValue = function () {&#13;
        return this.value;&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.setViewValue = function (value) {&#13;
        return this.$view.val(value);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap = function (htmlID, correctAnswers, gapScore) {&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
            createView: presenter.DraggableDroppableGap.prototype.createView,&#13;
&#13;
            showAnswersValue: correctAnswers,&#13;
            fillGap: presenter.DraggableDroppableGap.prototype.fillGap,&#13;
            makeGapEmpty: presenter.DraggableDroppableGap.prototype.makeGapEmpty,&#13;
&#13;
            gapScore: gapScore&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.DraggableDroppableGap.parent = presenter.GapUtils.prototype;&#13;
    presenter.DraggableDroppableGap.constructor = presenter.DraggableDroppableGap;&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.createView = function () {&#13;
        var $view = DraggableDroppableObject.prototype.createView.call(this);&#13;
&#13;
        $view.css({&#13;
            width: presenter.configuration.gapWidth + "px",&#13;
            display: 'inline-block'&#13;
        });&#13;
&#13;
        $view.addClass("draggable-gap");&#13;
        $view.addClass("ic_gap");&#13;
&#13;
        return $view;&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        DraggableDroppableObject.prototype.lock.call(this);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        DraggableDroppableObject.prototype.unlock.call(this);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.fillGap = function (selectedItem) {&#13;
        DraggableDroppableObject.prototype.fillGap.call(this, selectedItem);&#13;
        this.addCssClass("gapFilled");&#13;
        this.notify();&#13;
&#13;
        presenter.renderMathJax();&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.makeGapEmpty = function () {&#13;
        DraggableDroppableObject.prototype.makeGapEmpty.call(this);&#13;
        this.removeCssClass("gapFilled");&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject = function () {&#13;
        this.gaps = [];&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.addGap = function (gap) {&#13;
        this.gaps.push(gap);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.replaceDOMViewWithGap = function () {&#13;
        this.gaps.filter(function (gap) {&#13;
            return gap.gapType == presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        }).forEach(function (gap) {&#13;
            var gapID = "#" + gap.getObjectID(),&#13;
                element = presenter.$view.find(gapID),&#13;
                placeholder = element.attr("placeholder");&#13;
&#13;
            element.replaceWith(gap.getView());&#13;
            element = presenter.$view.find(gapID);&#13;
            if(placeholder) {&#13;
                element.attr("placeholder", placeholder);&#13;
                element.removeClass("ic_gap").addClass("ic_filled_gap");&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.replaceGapsDOMWithView = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.$view = presenter.$view.find("#" + gap.getObjectID());&#13;
            if(!presenter.isPreview){&#13;
                gap.connectEvents();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.removeAllGapsClasses = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.removeAllClasses();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.check = function (isSetShow) {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.check(isSetShow);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.showAnswers = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.showAnswers();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.showAnswersMath = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            if(gap.mathShowAnswersValue != ""){&#13;
                gap.showAnswers();&#13;
            }else{&#13;
                gap.lock();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.hideAnswers = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.hideAnswers();&#13;
            gap.removeAllClasses();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.reset = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.reset();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getErrorCount = function () {&#13;
        return this.gaps.reduce(function (errorCount, gap) {&#13;
            return errorCount += gap.getErrorCount();&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getScore = function () {&#13;
        return this.gaps.reduce(function (score, gap) {&#13;
            return score += gap.getScore();&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getMaxScore = function () {&#13;
        return this.gaps.reduce(function (maxScore, gap) {&#13;
            return maxScore += gap.gapScore;&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexWithClass = function (index, cssClass) {&#13;
        this.gaps[index].removeAllClasses();&#13;
        this.gaps[index].addCssClass(cssClass);&#13;
        this.gaps[index].notifyEdit();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsCorrect = function (index) {&#13;
        this.markGapByIndexWithClass(index, this.gaps[index].correctCSS);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsWrong = function (index) {&#13;
        this.markGapByIndexWithClass(index, this.gaps[index].wrongCSS);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsEmpty = function (index) {&#13;
        this.markGapByIndexWithClass(index, 'ic_gap-empty');&#13;
    };&#13;
    &#13;
    presenter.GapsContainerObject.prototype.getLength = function () {&#13;
        return this.gaps.length;&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapValueByIndex = function (index) {&#13;
        return this.gaps[index].getValue();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setLockGapByIndex = function (index, lock) {&#13;
        this.gaps[index].setIsEnabled(lock);&#13;
        this.gaps[index].notifyEdit();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockGapByIndex = function (index) {&#13;
        this.setLockGapByIndex(index, false);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.unlockGapByIndex = function (index) {&#13;
        this.setLockGapByIndex(index, true);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.unlockAllGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            this.unlockGapByIndex(index);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockAllGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            this.lockGapByIndex(index);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockAllNotEmptyGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            if(!gap.isValueEmpty()){&#13;
                this.lockGapByIndex(index);&#13;
            }&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapIndexByObjectID = function (objectID) {&#13;
        for (var index = 0; index &lt; this.gaps.length; index++) {&#13;
            if (this.gaps[index].getObjectID() === objectID) {&#13;
                return (index + 1);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapsState = function () {&#13;
        return this.gaps.map(function (gap) {&#13;
            return gap.getGapState();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getState = function () {&#13;
        return this.gaps.map(function (gap) {&#13;
            return gap.getState();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setGapsState = function (state) {&#13;
        state.map(function (stateData, index) {&#13;
            this.gaps[index].setState(stateData.value, "", stateData.isEnabled);&#13;
            this.gaps[index].$view.trigger('change');&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setSpansState = function (state, undefinedAttr) {&#13;
        if ((state !== undefinedAttr) &amp;&amp; (state !== null)) {&#13;
            state.map(function (stateData, index) {&#13;
                this.gaps[index].setState(stateData.value, stateData.item, undefined, stateData.droppedElement);&#13;
&#13;
                if (stateData.value == "") {&#13;
                    this.gaps[index].destroyDraggableProperty();&#13;
                }else{&#13;
                    this.gaps[index].addCssClass("gapFilled");&#13;
                }&#13;
&#13;
            }, this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setMathShowAnswersValueByGapIndex = function (index, value) {&#13;
        this.gaps[index].setMathShowAnswersValue(value);&#13;
    };&#13;
&#13;
    presenter.ValueChangeObserver = function () {};&#13;
&#13;
    presenter.ValueChangeObserver.prototype.notify = function (data) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', this.getEventData(data));&#13;
&#13;
        if (presenter.isAllOK()) presenter.sendAllOKEvent();&#13;
    };&#13;
&#13;
    presenter.ValueChangeObserver.prototype.getEventData = function (data) {&#13;
        return {&#13;
            score: data.isCorrect ? "1" : "0",&#13;
            value: data.value,&#13;
            source: presenter.configuration.addonID,&#13;
            item: presenter.gapsContainer.getGapIndexByObjectID(data.objectID)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.isActivity = function () {&#13;
        return presenter.configuration.isActivity;&#13;
    };&#13;
&#13;
    presenter.setMathShowAnswersCounter = function (counter) {&#13;
        presenter.configuration.mathShowAnswersCounter = counter;&#13;
    };&#13;
&#13;
    presenter.tickMathCounter = function () {&#13;
        if (presenter.configuration.mathShowAnswersCounter) {&#13;
            presenter.configuration.mathShowAnswersCounter = presenter.configuration.mathShowAnswersCounter - 1;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.shouldTriggerMathShowAnswers = function () {&#13;
        return presenter.configuration.mathShowAnswersCounter == 0;&#13;
    };&#13;
&#13;
    //showAnswers from Math&#13;
    presenter.setGapAnswer = function (gapIndex, answer, counter) {&#13;
        if (presenter.configuration.mathShowAnswersCounter === undefined) {&#13;
            presenter.setMathShowAnswersCounter(counter);&#13;
        }&#13;
&#13;
        presenter.gapsContainer.setMathShowAnswersValueByGapIndex((gapIndex - 1), answer);&#13;
&#13;
        presenter.tickMathCounter();&#13;
&#13;
        if (presenter.shouldTriggerMathShowAnswers()) {&#13;
            presenter.gapsContainer.removeAllGapsClasses();&#13;
            presenter.gapsContainer.showAnswersMath();&#13;
            presenter.setMathShowAnswersCounter(counter);&#13;
        }&#13;
    };&#13;
&#13;
    //hideAnswers from Math&#13;
    //hideAnswers is called anyway so just void function&#13;
    presenter.setUserValue = function () {};&#13;
&#13;
    presenter.markConnectionWithMath = function() {&#13;
        isConnectedWithMath = true;&#13;
        presenter.isConnectedWithMath = true;&#13;
    };&#13;
&#13;
    presenter.getValue = function (index) {&#13;
        return presenter.gapsContainer.getGapValueByIndex((index-1))&#13;
    };&#13;
&#13;
    presenter.renderMathJax = function () {&#13;
        MathJax.CallBack.Queue().Push(function () {&#13;
            MathJax.Hub.Typeset(presenter.$view.find(".table-addon-wrapper")[0]);&#13;
        });&#13;
    };&#13;
&#13;
    function TableKeyboardController (elements, columnsCount, rowsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
        this.rowsCount = rowsCount;&#13;
    }&#13;
&#13;
    TableKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    TableKeyboardController.prototype.constructor = TableKeyboardController;&#13;
&#13;
    TableKeyboardController.prototype.select = function (event) {&#13;
        event.preventDefault();&#13;
        if (presenter.gapNavigation &amp;&amp; presenter.configuration.gapType == 'draggable' &amp;&amp; presenter.getCurrentGapsNumber() &gt; 0) {&#13;
            var $gap = presenter.getGap(presenter.gapIndex);&#13;
&#13;
            if (!$gap || !$gap.is('span')) return;&#13;
&#13;
            var oldVal = $gap.text();&#13;
            $gap.click();&#13;
            var value = $gap.text();&#13;
&#13;
            if (0 !== oldVal.localeCompare(value)) {&#13;
                var data = [];&#13;
                if (value) {&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(value, presenter.configuration.langTag));&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.inserted));&#13;
                } else {&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(oldVal, presenter.configuration.langTag));&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.removed));&#13;
                }&#13;
                presenter.speak(data);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.mark =  function (element) {&#13;
        KeyboardController.prototype.mark.call(this, element);&#13;
        this.getTarget(element, false).focus();&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.unmark = function (element) {&#13;
        KeyboardController.prototype.unmark.call(this, element);&#13;
        this.getTarget(element, false).blur();&#13;
    };&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        presenter.keyboardControllerObject = new TableKeyboardController(presenter.getElementsForKeyboardNavigation(), presenter.configuration.columnsCount, presenter.configuration.rowsCount);&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.$view.find('td');&#13;
    };&#13;
&#13;
    presenter.keyboardController = function(keycode, isShiftKeyDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.getTarget = function (element, willBeClicked){&#13;
        return $(element);&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.escape = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            if (event) {&#13;
                event.stopPropagation();&#13;
                event.preventDefault();&#13;
            }&#13;
            presenter.gapNavigation = false;&#13;
            presenter.clearCurrentCell();&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            // must be set to false, otherwise module won't exit navigation&#13;
            presenter.addonKeyboardNavigationActive = false;&#13;
            KeyboardController.prototype.escape.call(this, event);&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.enter = function (event){&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
&#13;
        if (presenter.addonKeyboardNavigationActive &amp;&amp; !presenter.gapNavigation) {&#13;
            presenter.gapNavigation = true;&#13;
            presenter.selectGap(0);&#13;
        }&#13;
        if (!presenter.addonKeyboardNavigationActive){&#13;
            presenter.addonKeyboardNavigationActive = true;&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            presenter.readCurrentNavigationElement();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.readCurrentNavigationElement = function() {&#13;
        var html = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
        var data = window.TTSUtils.getTextVoiceArrayFromElementWithGaps(html, presenter.configuration.langTag, presenter.speechTexts);&#13;
        presenter.speak(data);&#13;
    };&#13;
&#13;
    presenter.readCurrentCellTitle = function() {&#13;
        var row = Math.floor(presenter.keyboardControllerObject.keyboardNavigationCurrentElementIndex / presenter.configuration.columnsCount);&#13;
        var column = presenter.keyboardControllerObject.keyboardNavigationCurrentElementIndex % presenter.configuration.columnsCount;&#13;
        var alphabet = "ABCDEFGHIJKLMNOPRSTUWXYZ";&#13;
        var content = presenter.speechTexts.cell + " " + alphabet[column % alphabet.length] + " " + (row+1);&#13;
        var data = [window.TTSUtils.getTextVoiceObject(content)];&#13;
        presenter.speak(data);&#13;
    };&#13;
&#13;
    // TAB or Right Arrow&#13;
    TableKeyboardController.prototype.nextElement = function (event) {&#13;
        if(event.keyCode === 9) { //TAB&#13;
            this.handleTab(event);&#13;
            event.preventDefault();&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.gapNavigation){&#13;
            presenter.switchSelectedValue(1);&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        if (this.keyboardNavigationCurrentElementIndex % this.columnsCount === this.columnsCount - 1) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(1);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    // SHIFT+TAB or Left Arrow&#13;
    TableKeyboardController.prototype.previousElement = function (event) {&#13;
        if(event.keyCode === 9) { //TAB&#13;
            this.handleTab(event);&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.gapNavigation){&#13;
            presenter.switchSelectedValue(-1);&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        if (this.keyboardNavigationCurrentElementIndex % this.columnsCount === 0) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(-1);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.handleTab = function (event) {&#13;
        if (presenter.getCurrentGapsNumber() &gt; 0) {&#13;
            if (!presenter.gapNavigation) {&#13;
                presenter.gapNavigation = true;&#13;
                presenter.selectGap(0);&#13;
            } else {&#13;
                if ( !event.shiftKey ) {&#13;
                    presenter.selectGap(presenter.gapIndex + 1);&#13;
                } else {&#13;
                    presenter.selectGap(presenter.gapIndex - 1);&#13;
                }&#13;
            }&#13;
&#13;
            var $gap = presenter.getGap(presenter.gapIndex);&#13;
            var $cell = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
            var data = window.TTSUtils.getTextVoiceArrayFromGap($gap, $cell, presenter.configuration.langTag, presenter.speechTexts);&#13;
            presenter.speak(data);&#13;
&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    // UP Arrow&#13;
    TableKeyboardController.prototype.previousRow = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            presenter.switchSelectedValue(-1);&#13;
            return;&#13;
        }&#13;
&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (Math.floor(this.keyboardNavigationCurrentElementIndex / this.columnsCount) === 0) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(-this.columnsCount);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    // DOWN Arrow&#13;
    TableKeyboardController.prototype.nextRow = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            presenter.switchSelectedValue(1);&#13;
            return;&#13;
        }&#13;
&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (Math.floor(this.keyboardNavigationCurrentElementIndex / this.columnsCount) === this.rowsCount - 1) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(this.columnsCount);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.exitWCAGMode = function () {&#13;
        presenter.gapNavigation = false;&#13;
        presenter.clearCurrentCell();&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function AddonTable_getTextToSpeechOrNull(playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function AddonTable_setWCAGStatus(isOn) {&#13;
        presenter.isWCAGOn = isOn;&#13;
    };&#13;
&#13;
    presenter.speak = function AddonTable_speak(data) {&#13;
        var tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isDeactivationBlocked = function() {&#13;
        return presenter.addonKeyboardNavigationActive || presenter.gapNavigation;&#13;
    };&#13;
&#13;
    presenter.getCurrentGapsNumber = function() {&#13;
        return $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice').length;&#13;
    };&#13;
&#13;
    presenter.clearCurrentCell = function() {&#13;
        var $cell = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
        $cell.find('.keyboard_navigation_active_element').removeClass('keyboard_navigation_active_element');&#13;
        if ($cell.find('input:focus').length &gt; 0) {&#13;
            $cell.find('input:focus').blur();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getGap = function (index) {&#13;
        var $gaps = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice');&#13;
        if ($gaps.length == 0) return;&#13;
        if (index &lt; 0) index = 0;&#13;
        if (index &gt;= $gaps.length) index = $gaps.length-1;&#13;
        return $gaps.eq(index);&#13;
    };&#13;
&#13;
    presenter.selectGap = function(index) {&#13;
        var $gaps = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice');&#13;
        if ($gaps.length == 0) return;&#13;
        if(index &lt; 0) index = 0;&#13;
        if(index &gt;= $gaps.length) index = $gaps.length - 1;&#13;
        var $gap = $gaps.eq(index);&#13;
&#13;
        presenter.clearCurrentCell();&#13;
        $gap.addClass('keyboard_navigation_active_element');&#13;
&#13;
        presenter.gapIndex = index;&#13;
        if ($gap.is('input')) {&#13;
            $gap.focus();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.switchSelectedValue = function(move) {&#13;
        if(presenter.isShowAnswersActive || presenter.isSetShowErrorsMode) return;&#13;
        var $gap = presenter.getGap(presenter.gapIndex);&#13;
&#13;
        if (!$gap || !$gap.is('select')) return;&#13;
&#13;
        var index = $gap.prop("selectedIndex");&#13;
        var optionSize = $gap.find('option').size();&#13;
        index = index + move;&#13;
&#13;
        if (0 &lt;= index &amp;&amp; index &lt; optionSize) {&#13;
            $gap.prop("selectedIndex", index);&#13;
            $gap.change();&#13;
            var value = $gap.val();&#13;
            if (value.length == 0 || value == '-' || value == '---') {&#13;
                var data = [window.TTSUtils.getTextVoiceObject(presenter.speechTexts.empty)];&#13;
            } else {&#13;
                var data = [window.TTSUtils.getTextVoiceObject($gap.val(), presenter.configuration.langTag)];&#13;
            }&#13;
            presenter.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>