{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { Http, Headers, RequestOptions } from \"@angular/http\";\nimport { Observable } from \"rxjs/Observable\";\nimport { map, catchError } from \"rxjs/operators\";\nimport \"rxjs/add/observable/throw\";\nimport { TokenService } from \"./token.service\";\nimport { InfoMessageService } from \"./info-message.service\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./token.service\";\nimport * as i2 from \"./info-message.service\";\nvar API_URL = \"/api/v2\";\nexport var UNAUTHORIZED_ERROR = \"Unauthorized\";\nvar SERVER_RESPONSE_STATUS = {\n  UNAUTHORIZED: 401,\n  FORBIDDEN: 403,\n  INTERNAL_SERVER_ERROR: 500\n};\nvar REQUEST_TYPES = {\n  GET: \"get\",\n  POST: \"post\",\n  PUT: \"put\",\n  COPY: \"copy\",\n  DELETE: \"delete\"\n};\nvar RestClientService = /** @class */function () {\n  function RestClientService(_http, _token, _infoMessage) {\n    this._http = _http;\n    this._token = _token;\n    this._infoMessage = _infoMessage;\n  }\n  RestClientService.prototype.get = function (url) {\n    return this.requestWithToken(this.getOptions, this.handleError, REQUEST_TYPES.GET, url);\n  };\n  RestClientService.prototype.getPublic = function (url) {\n    var _this = this;\n    return this._http.get(API_URL + url, this.getOptions()).pipe(map(this.extractData), catchError(function (error) {\n      return _this.handleError(error, _this);\n    }));\n  };\n  RestClientService.prototype.post = function (url, params) {\n    if (params === void 0) {\n      params = {};\n    }\n    return this.requestWithToken(this.getPostOptions, this.handlePostError, REQUEST_TYPES.POST, url, params);\n  };\n  RestClientService.prototype.postPublic = function (url, params) {\n    var _this = this;\n    return this._http.post(API_URL + url, JSON.stringify(params), this.getPostOptions()).pipe(map(this.extractData), catchError(function (error) {\n      return _this.handlePostError(error, _this);\n    }));\n  };\n  RestClientService.prototype.put = function (url, params) {\n    return this.requestWithToken(this.getPostOptions, this.handlePostError, REQUEST_TYPES.PUT, url, params);\n  };\n  RestClientService.prototype.putPublic = function (url, params) {\n    var _this = this;\n    if (params === void 0) {\n      params = {};\n    }\n    return this._http.put(API_URL + url, JSON.stringify(params), this.getPostOptions()).pipe(map(this.extractData), catchError(function (error) {\n      return _this.handlePostError(error, _this);\n    }));\n  };\n  RestClientService.prototype.delete = function (url) {\n    return this.requestWithToken(this.getOptions, this.handlePostError, REQUEST_TYPES.DELETE, url);\n  };\n  RestClientService.prototype.extractData = function (res) {\n    if (res.status < 200 || res.status >= 300) {\n      throw new Error(\"BAD RESPONSE STATUS: \" + res.status);\n    }\n    if (res) {\n      try {\n        return res.json();\n      } catch (e) {}\n    }\n    return null;\n  };\n  RestClientService.prototype.handleError = function (error, that) {\n    var errMsg = error.status || \"Server error\";\n    console.error(\"RestClientService ERROR: \", errMsg);\n    if (error.status === SERVER_RESPONSE_STATUS.INTERNAL_SERVER_ERROR) {\n      that._infoMessage.error500();\n    }\n    return Observable.throw(error);\n  };\n  RestClientService.prototype.handlePostError = function (error, that) {\n    var errMsg = error.status || \"Server error\";\n    console.error(\"RestClientService ERROR: \", errMsg);\n    error.body = JSON.parse(error._body);\n    if (error.status === SERVER_RESPONSE_STATUS.INTERNAL_SERVER_ERROR) {\n      that._infoMessage.error500();\n    }\n    return Observable.throw(error);\n  };\n  RestClientService.prototype.getOptions = function (headers) {\n    if (headers === void 0) {\n      headers = {};\n    }\n    headers[\"Accept\"] = \"application/json\";\n    return new RequestOptions({\n      headers: new Headers(headers)\n    });\n  };\n  RestClientService.prototype.getPostOptions = function (headers) {\n    if (headers === void 0) {\n      headers = {};\n    }\n    headers[\"Accept\"] = \"application/json\";\n    headers[\"Content-Type\"] = \"application/json\";\n    return new RequestOptions({\n      headers: new Headers(headers)\n    });\n  };\n  RestClientService.prototype.getTokenHeader = function (token) {\n    return {\n      Authorization: \"JWT \" + token\n    };\n  };\n  /*\r\n     1. get token,\r\n     2. if there is no token then throw Unauthorized error,\r\n     3. else do request with header: Authorization: JWT(space)token,\r\n     4. if request fails and error's status is 401 (Unauthorized) then\r\n          clear old token and redo request,\r\n     5. else let error to be raised.\r\n   */\n  RestClientService.prototype.requestWithToken = function (getOptions, handleError, methodName) {\n    var _this = this;\n    var params = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n      params[_i - 3] = arguments[_i];\n    }\n    return Observable.create(function (observer) {\n      _this._token.get().subscribe(function (token) {\n        if (!token) {\n          observer.error(UNAUTHORIZED_ERROR);\n        } else {\n          var options = _this.getRequestOptions.apply(_this, __spreadArray([methodName, getOptions(_this.getTokenHeader(token))], params, false));\n          _this._http.request(API_URL + params[0], options).pipe(map(_this.extractData), catchError(function (error) {\n            return handleError(error, _this);\n          })).subscribe(function (data) {\n            observer.next(data);\n            observer.complete();\n          }, function (error) {\n            if (parseInt(error.status) === SERVER_RESPONSE_STATUS.UNAUTHORIZED) {\n              _this._token.clear();\n              _this[methodName].apply(_this, params).pipe(catchError(function (error) {\n                return handleError(error, _this);\n              })).subscribe(function (data) {\n                observer.next(data);\n                observer.complete();\n              }, function (error) {\n                observer.error(error);\n              });\n            } else {\n              observer.error(error);\n            }\n          });\n        }\n      });\n    });\n  };\n  RestClientService.prototype.getRequestOptions = function (methodName, options) {\n    var params = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n      params[_i - 2] = arguments[_i];\n    }\n    options.method = methodName;\n    if (params.length > 1) {\n      options.body = params[1];\n    }\n    return options;\n  };\n  RestClientService.ɵfac = function RestClientService_Factory(t) {\n    i0.ɵɵinvalidFactory();\n  };\n  RestClientService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: RestClientService,\n    factory: RestClientService.ɵfac\n  });\n  return RestClientService;\n}();\nexport { RestClientService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}